LANGUAGE = "pseudocode"        # ← purely illustrative; not a real language.

############################################################
#  MOS 6502 — LITERATE, IMPERATIVE PSEUDO-CODE EMULATOR   #
#  Focus: clarity, correctness, portability               #
############################################################


########################################
# SECTION 0 — NUMERIC & BIT CONVENTIONS
########################################
#  • All integer registers are 8-bit unless stated.
#  • Memory is 64 KiB ($0x0000$..$0xFFFF$).
#  • "$" marks hexadecimal in comments; arithmetic is done modulo 8 or 16 bits as stated.
#  • The 6502 sets flags NV-BDIZC (bit 7..0).
#  • "page" means a 256-byte block (high byte of an address).
#  • "page crossing" = effective address crosses a 256-byte boundary after adding X/Y.

CONST MASK_BYTE     = 0xFF
CONST MASK_WORD     = 0xFFFF

# Status bits:
CONST FLAG_N = 0x80   # Negative
CONST FLAG_V = 0x40   # Overflow
CONST FLAG_X = 0x20   # Unused/ignored bit in P (always reads as set when pushed)
CONST FLAG_B = 0x10   # Break (software)
CONST FLAG_D = 0x08   # Decimal (BCD arith)
CONST FLAG_I = 0x04   # IRQ Disable
CONST FLAG_Z = 0x02   # Zero
CONST FLAG_C = 0x01   # Carry

# Interrupt vectors:
CONST VEC_NMI   = 0xFFFA
CONST VEC_RESET = 0xFFFC
CONST VEC_IRQ   = 0xFFFE   # also used by BRK



######################################
# SECTION 1 — CPU STATE & THE "BUS"
######################################
STRUCT CPU:
    A  : u8         # Accumulator
    X  : u8         # Index X
    Y  : u8         # Index Y
    P  : u8         # Status NV-BDIZC
    SP : u8         # Stack Pointer (stack at $0100$..$01FF$)
    PC : u16        # Program Counter

    cycles : u64    # total elapsed cycles (running sum)
    running: bool   # main loop latch

    pending_NMI : bool
    pending_IRQ : bool        # level IRQ (maskable by I)

END


# === MEMORY/BUS ==========================================
# Memory map: by default a flat 64 KiB RAM. Hook points allow MMIO/cartridge.

ARRAY MEMORY[0..65535] : u8 = {0}   # default zeroed

# Optional user hooks (can be "null"/unset):
FUNCTION BUS_READ_HOOK(addr: u16)  RETURNS (has_value: bool, value: u8)
FUNCTION BUS_WRITE_HOOK(addr: u16, value: u8) RETURNS (handled: bool)

# 8-bit read
FUNCTION READ8(addr: u16) RETURNS u8:
    addr := addr AND MASK_WORD
    (has, val) := BUS_READ_HOOK(addr)  IF set
    IF has == true:
        RETURN val
    ELSE:
        RETURN MEMORY[addr]
    END
END

# 8-bit write
FUNCTION WRITE8(addr: u16, value: u8):
    addr  := addr  AND MASK_WORD
    value := value AND MASK_BYTE
    handled := BUS_WRITE_HOOK(addr, value)  IF set
    IF handled != true:
        MEMORY[addr] := value
    END
END

# Read two bytes little-endian from arbitrary address (wraps naturally page-to-page)
FUNCTION READ16(addr: u16) RETURNS u16:
    lo := READ8(addr)
    hi := READ8(addr + 1)
    RETURN ((hi << 8) OR lo)
END

# Read two bytes little-endian from ZERO PAGE with 8-bit wrap ($FF+1→$00)
FUNCTION READ16_ZP(zp_addr: u8) RETURNS u16:
    lo := READ8(zp_addr)
    hi := READ8((zp_addr + 1) AND 0xFF)
    RETURN ((hi << 8) OR lo)
END

# Stack helpers ($0100$ base)
FUNCTION PUSH8(C: CPU, value: u8):
    WRITE8(0x0100 OR C.SP, value)
    C.SP := (C.SP - 1) AND 0xFF
END

FUNCTION POP8(C: CPU) RETURNS u8:
    C.SP := (C.SP + 1) AND 0xFF
    RETURN READ8(0x0100 OR C.SP)
END

FUNCTION PUSH16(C: CPU, value: u16):
    # Push high then low? 6502 pushes PC high, then low. We encode that explicitly where needed.
    hi := (value >> 8) AND 0xFF
    lo := value AND 0xFF
    PUSH8(C, hi)
    PUSH8(C, lo)
END

FUNCTION POP16(C: CPU) RETURNS u16:
    lo := POP8(C)
    hi := POP8(C)
    RETURN ((hi << 8) OR lo)
END



#########################################
# SECTION 2 — FLAGS (P) CONVENIENCE
#########################################
FUNCTION SET_ZN(C: CPU, value8: u8):
    IF (value8 AND 0xFF) == 0: C.P := (C.P OR FLAG_Z)
    ELSE:                      C.P := (C.P AND (NOT FLAG_Z))
    END
    IF (value8 AND 0x80) != 0: C.P := (C.P OR FLAG_N)
    ELSE:                      C.P := (C.P AND (NOT FLAG_N))
    END
END

FUNCTION GET_FLAG(C: CPU, mask: u8) RETURNS bool:
    RETURN ((C.P AND mask) != 0)
END

FUNCTION SET_FLAG(C: CPU, mask: u8, on: bool):
    IF on:  C.P := (C.P OR  mask)
    ELSE:   C.P := (C.P AND (NOT mask))
    END
END



########################################################
# SECTION 3 — ADDRESSING MODES (effective address/val)
########################################################
# Each resolver returns:
#   (mode_kind, eff_addr, fetched, page_crossed)
# Where:
#   - eff_addr is the effective 16-bit address (if applicable)
#   - fetched is the immediate/accumulator value when relevant
#   - page_crossed is true when the X/Y addition crossed a page

# Helpers:
FUNCTION PAGE(addr: u16) RETURNS u8: RETURN ((addr >> 8) AND 0xFF) END

# --- IMPLIED / ACCUMULATOR --------------------------------
FUNCTION AM_IMPL(C: CPU) RETURNS (kind: "impl", addr: u16, val: u8, crossed: bool):
    RETURN ("impl", 0, 0, false)
END

FUNCTION AM_ACC(C: CPU) RETURNS (kind: "A", addr: u16, val: u8, crossed: bool):
    RETURN ("A", 0, C.A, false)
END

# --- IMMEDIATE --------------------------------------------
FUNCTION AM_IMM(C: CPU) RETURNS (kind, addr, val, crossed):
    val := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    RETURN ("#", 0, val, false)
END

# --- ZEROPAGE ----------------------------------------------
FUNCTION AM_ZP(C: CPU) RETURNS (...):
    zp := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    RETURN ("zpg", zp, READ8(zp), false)
END

FUNCTION AM_ZPX(C: CPU) RETURNS (...):
    zp := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    eff := (zp + C.X) AND 0xFF
    RETURN ("zpg,X", eff, READ8(eff), false)
END

FUNCTION AM_ZPY(C: CPU) RETURNS (...):
    zp := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    eff := (zp + C.Y) AND 0xFF
    RETURN ("zpg,Y", eff, READ8(eff), false)
END

# --- ABSOLUTE ----------------------------------------------
FUNCTION AM_ABS(C: CPU) RETURNS (...):
    addr := READ16(C.PC) ; C.PC := (C.PC + 2) AND 0xFFFF
    RETURN ("abs", addr, READ8(addr), false)
END

FUNCTION AM_ABX(C: CPU) RETURNS (...):
    base := READ16(C.PC) ; C.PC := (C.PC + 2) AND 0xFFFF
    eff  := (base + C.X) AND 0xFFFF
    crossed := (PAGE(base) != PAGE(eff))
    RETURN ("abs,X", eff, READ8(eff), crossed)
END

FUNCTION AM_ABY(C: CPU) RETURNS (...):
    base := READ16(C.PC) ; C.PC := (C.PC + 2) AND 0xFFFF
    eff  := (base + C.Y) AND 0xFFFF
    crossed := (PAGE(base) != PAGE(eff))
    RETURN ("abs,Y", eff, READ8(eff), crossed)
END

# --- INDIRECT (JMP only) with 6502 wraparound bug ----------
FUNCTION AM_IND(C: CPU) RETURNS (...):
    ptr := READ16(C.PC) ; C.PC := (C.PC + 2) AND 0xFFFF
    lo := READ8(ptr)
    # Bug: high byte wraps within the same page (do not cross to next page)
    hi_addr := (ptr AND 0xFF00) OR ((ptr + 1) AND 0x00FF)
    hi := READ8(hi_addr)
    dest := ((hi << 8) OR lo)
    RETURN ("ind", dest, 0, false)
END

# --- (X,ind) : pre-indexed zero-page -----------------------
FUNCTION AM_XIND(C: CPU) RETURNS (...):
    zp := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    ptr := (zp + C.X) AND 0xFF
    eff := READ16_ZP(ptr)
    RETURN ("X,ind", eff, READ8(eff), false)
END

# --- (ind),Y : post-indexed zero-page ----------------------
FUNCTION AM_INDY(C: CPU) RETURNS (...):
    zp   := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    base := READ16_ZP(zp)
    eff  := (base + C.Y) AND 0xFFFF
    crossed := (PAGE(base) != PAGE(eff))
    RETURN ("ind,Y", eff, READ8(eff), crossed)
END

# --- RELATIVE (branches) ----------------------------------
FUNCTION AM_REL(C: CPU) RETURNS (...):
    off8 := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    # signed 8-bit: $-128..+127$
    signed := (off8 >= 0x80) ? (off8 - 256) : off8
    target := (C.PC + signed) AND 0xFFFF
    RETURN ("rel", target, 0, false)
END



######################################################
# SECTION 4 — DISPATCHUCTION BYTES & CYCLES DEFINITIONS
######################################################
# Instruction SIZE (bytes) is determined entirely by addressing mode.
FUNCTION DISPATCH_BYTES_FOR_MODE(mode: string) RETURNS u8:
    IF mode IN {"impl", "A"}: RETURN 1
    IF mode IN {"#", "zpg", "zpg,X", "zpg,Y", "X,ind", "ind,Y", "rel"}: RETURN 2
    IF mode IN {"abs", "abs,X", "abs,Y", "ind"}: RETURN 3
    ABORT("unknown mode")
END

# BASE CYCLES TABLE (official NMOS 6502). Uses the convention:
#   • return (base_cycles, adds_on_page_cross) where the latter is true
#     only when the mode causes an extra cycle if a page is crossed.
FUNCTION CYCLES_BASE(mnemonic: string, mode: string) RETURNS (u8, bool):
    # ALU loads (ADC, AND, CMP, EOR, LDA, ORA, SBC) and also CP* & BIT as noted:
    IF mnemonic IN {"ADC","AND","CMP","EOR","LDA","ORA","SBC"}:
        SWITCH mode:
            CASE "#":     RETURN (2,false)
            CASE "zpg":   RETURN (3,false)
            CASE "zpg,X": RETURN (4,false)
            CASE "abs":   RETURN (4,false)
            CASE "abs,X": RETURN (4,true)   # +1 on page cross
            CASE "abs,Y": RETURN (4,true)
            CASE "X,ind": RETURN (6,false)
            CASE "ind,Y": RETURN (5,true)
        END
    IF mnemonic == "STA":
        SWITCH mode:
            CASE "zpg":   RETURN (3,false)
            CASE "zpg,X": RETURN (4,false)
            CASE "abs":   RETURN (4,false)
            CASE "abs,X": RETURN (5,false)
            CASE "abs,Y": RETURN (5,false)
            CASE "X,ind": RETURN (6,false)
            CASE "ind,Y": RETURN (6,false)
        END
    IF mnemonic == "STX":
        SWITCH mode:
            CASE "zpg":   RETURN (3,false)
            CASE "abs":   RETURN (4,false)
            CASE "zpg,Y": RETURN (4,false)
        END
    IF mnemonic == "STY":
        SWITCH mode:
            CASE "zpg":   RETURN (3,false)
            CASE "abs":   RETURN (4,false)
            CASE "zpg,X": RETURN (4,false)
        END
    IF mnemonic == "LDX":
        SWITCH mode:
            CASE "#":     RETURN (2,false)
            CASE "zpg":   RETURN (3,false)
            CASE "zpg,Y": RETURN (4,false)
            CASE "abs":   RETURN (4,false)
            CASE "abs,Y": RETURN (4,true)
        END
    IF mnemonic == "LDY":
        SWITCH mode:
            CASE "#":     RETURN (2,false)
            CASE "zpg":   RETURN (3,false)
            CASE "zpg,X": RETURN (4,false)
            CASE "abs":   RETURN (4,false)
            CASE "abs,X": RETURN (4,true)
        END
    IF mnemonic IN {"ASL","LSR","ROL","ROR"}:
        SWITCH mode:
            CASE "A":      RETURN (2,false)
            CASE "zpg":    RETURN (5,false)
            CASE "zpg,X":  RETURN (6,false)
            CASE "abs":    RETURN (6,false)
            CASE "abs,X":  RETURN (7,false)
        END
    IF mnemonic IN {"INC","DEC"}:
        SWITCH mode:
            CASE "zpg":    RETURN (5,false)
            CASE "zpg,X":  RETURN (6,false)
            CASE "abs":    RETURN (6,false)
            CASE "abs,X":  RETURN (7,false)
        END
    IF mnemonic == "BIT":
        SWITCH mode:
            CASE "zpg": RETURN (3,false)
            CASE "abs": RETURN (4,false)
        END
    IF mnemonic IN {"BPL","BMI","BVC","BVS","BCC","BCS","BNE","BEQ"}:
        # 2 +1 if taken +1 if taken and page crossed
        RETURN (2,false)
    IF mnemonic == "JMP":
        SWITCH mode:
            CASE "abs": RETURN (3,false)
            CASE "ind": RETURN (5,false)
        END
    IF mnemonic == "JSR": RETURN (6,false)    # abs only
    IF mnemonic == "BRK": RETURN (7,false)
    IF mnemonic == "RTI": RETURN (6,false)
    IF mnemonic == "RTS": RETURN (6,false)
    IF mnemonic IN {"CLC","SEC","CLI","SEI","CLV","CLD","SED","NOP"}:
        RETURN (2,false)
    IF mnemonic IN {"TAX","TXA","TAY","TYA","TSX","TXS","DEX","DEY","INX","INY"}:
        RETURN (2,false)
    IF mnemonic == "CPX" OR mnemonic == "CPY":
        SWITCH mode:
            CASE "#":   RETURN (2,false)
            CASE "zpg": RETURN (3,false)
            CASE "abs": RETURN (4,false)
        END
    ABORT("cycles: unhandled mnemonic/mode: " + mnemonic + " " + mode)
END



###############################################################
# SECTION 5 — ALU CORE (BINARY + DECIMAL) AND COMMON HELPERS
###############################################################
# Binary add with carry; returns result and sets NVZC as per 6502
FUNCTION ADC_BINARY(C: CPU, M: u8):
    carry_in := GET_FLAG(C, FLAG_C) ? 1 : 0
    a := C.A
    sum9 := a + M + carry_in                      # conceptual 9-bit sum
    result := sum9 AND 0xFF
    # Flags:
    SET_FLAG(C, FLAG_C, (sum9 > 0xFF))
    SET_ZN(C, result)
    # Overflow: when the sign of A and M are same, but differ from result
    overflow := (((a XOR M) AND 0x80) == 0) AND (((a XOR result) AND 0x80) != 0)
    SET_FLAG(C, FLAG_V, overflow)
    C.A := result
END

# Decimal add (NMOS 6502 BCD semantics)
FUNCTION ADC_DECIMAL(C: CPU, M: u8):
    carry_in := GET_FLAG(C, FLAG_C) ? 1 : 0
    a := C.A
    # Perform binary add first to compute V per NMOS behavior
    bin_sum := (a + M + carry_in)
    bin_res := bin_sum AND 0xFF
    overflow := (((a XOR M) AND 0x80) == 0) AND (((a XOR bin_res) AND 0x80) != 0)
    # BCD adjust
    lo := (a AND 0x0F) + (M AND 0x0F) + carry_in
    adjust_lo := 0
    IF lo > 9: lo := lo + 6 ; adjust_lo := 1 END
    hi := (a >> 4) + (M >> 4) + (adjust_lo)
    carry_out := false
    IF hi > 9: hi := hi + 6 ; carry_out := true END
    result := ((hi << 4) OR (lo AND 0x0F)) AND 0xFF
    # Flags
    SET_FLAG(C, FLAG_C, carry_out)
    SET_ZN(C, result)
    SET_FLAG(C, FLAG_V, overflow)
    C.A := result
END

FUNCTION SBC_BINARY(C: CPU, M: u8):
    # 6502 SBC does A := A + (~M) + C, and C means "no borrow"
    carry_in := GET_FLAG(C, FLAG_C) ? 1 : 0
    a := C.A
    m_inv := M XOR 0xFF
    sum9 := a + m_inv + carry_in
    result := sum9 AND 0xFF
    SET_FLAG(C, FLAG_C, (sum9 > 0xFF))         # C=1 means no borrow
    SET_ZN(C, result)
    overflow := (((a XOR m_inv) AND 0x80) == 0) AND (((a XOR result) AND 0x80) != 0)
    SET_FLAG(C, FLAG_V, overflow)
    C.A := result
END

FUNCTION SBC_DECIMAL(C: CPU, M: u8):
    # Binary part for V
    carry_in := GET_FLAG(C, FLAG_C) ? 1 : 0
    a := C.A
    bin_diff := a - M - (1 - carry_in)
    bin_res := bin_diff AND 0xFF
    overflow := (((a XOR M) AND 0x80) != 0) AND (((a XOR bin_res) AND 0x80) != 0)
    # BCD adjust (NMOS rules)
    a_lo := a AND 0x0F
    m_lo := M AND 0x0F
    borrow := (1 - carry_in)
    lo := a_lo - m_lo - borrow
    adj_lo := 0
    if_borrow_lo := (lo < 0)
    IF if_borrow_lo: lo := lo - 6 END
    hi := (a >> 4) - (M >> 4) - (if_borrow_lo ? 1 : 0)
    carry_out := true
    IF hi < 0: hi := hi - 6 ; carry_out := false END
    result := ((hi << 4) OR (lo AND 0x0F)) AND 0xFF
    SET_FLAG(C, FLAG_C, carry_out)     # C=1 means no borrow
    SET_ZN(C, result)
    SET_FLAG(C, FLAG_V, overflow)
    C.A := result
END

# Read-Modify-Write helper pattern (ASL/LSR/ROL/ROR/INC/DEC on memory)
FUNCTION RMW(C: CPU, addr: u16, op: function(u8)->(u8)):
    val := READ8(addr)
    new := op(val)
    WRITE8(addr, new)
    RETURN new
END

# Compare helper (CMP/CPX/CPY)
FUNCTION DO_CMP(C: CPU, reg_val: u8, M: u8):
    diff := (reg_val - M) AND 0x1FF
    SET_FLAG(C, FLAG_C, reg_val >= M)
    SET_ZN(C, diff AND 0xFF)
END



#############################################
# SECTION 6 — MICRO-OPS FOR EACH MNEMONIC
#############################################
# These micro-ops do not fetch operands; addressing mode resolvers already did.
# Many ops are implemented generically.

# ---- Loads ------------------------------------------------
FUNCTION OP_LDA(C: CPU, val: u8):
    C.A := val AND 0xFF
    SET_ZN(C, C.A)
END

FUNCTION OP_LDX(C: CPU, val: u8):
    C.X := val AND 0xFF
    SET_ZN(C, C.X)
END

FUNCTION OP_LDY(C: CPU, val: u8):
    C.Y := val AND 0xFF
    SET_ZN(C, C.Y)
END

# ---- Stores -----------------------------------------------
FUNCTION OP_STA(C: CPU, addr: u16): WRITE8(addr, C.A) END
FUNCTION OP_STX(C: CPU, addr: u16): WRITE8(addr, C.X) END
FUNCTION OP_STY(C: CPU, addr: u16): WRITE8(addr, C.Y) END

# ---- ALU logic --------------------------------------------
FUNCTION OP_AND(C: CPU, val: u8): C.A := C.A AND val ; SET_ZN(C, C.A) END
FUNCTION OP_ORA(C: CPU, val: u8): C.A := C.A OR  val ; SET_ZN(C, C.A) END
FUNCTION OP_EOR(C: CPU, val: u8): C.A := C.A XOR val ; SET_ZN(C, C.A) END

# ---- ADC/SBC (with D check) -------------------------------
FUNCTION OP_ADC(C: CPU, val: u8):
    IF GET_FLAG(C, FLAG_D): ADC_DECIMAL(C, val)
    ELSE:                   ADC_BINARY (C, val)
    END
END

FUNCTION OP_SBC(C: CPU, val: u8):
    IF GET_FLAG(C, FLAG_D): SBC_DECIMAL(C, val)
    ELSE:                   SBC_BINARY (C, val)
    END
END

# ---- Shifts/Rotates ---------------------------------------
FUNCTION SH_ASL(C: CPU, v: u8) RETURNS u8:
    SET_FLAG(C, FLAG_C, (v AND 0x80) != 0)
    out := (v << 1) AND 0xFF
    SET_ZN(C, out)
    RETURN out
END

FUNCTION SH_LSR(C: CPU, v: u8) RETURNS u8:
    SET_FLAG(C, FLAG_C, (v AND 0x01) != 0)
    out := (v >> 1) AND 0xFF
    SET_ZN(C, out)
    RETURN out
END

FUNCTION SH_ROL(C: CPU, v: u8) RETURNS u8:
    oldC := GET_FLAG(C, FLAG_C) ? 1 : 0
    SET_FLAG(C, FLAG_C, (v AND 0x80) != 0)
    out := ((v << 1) OR oldC) AND 0xFF
    SET_ZN(C, out)
    RETURN out
END

FUNCTION SH_ROR(C: CPU, v: u8) RETURNS u8:
    oldC := GET_FLAG(C, FLAG_C) ? 1 : 0
    SET_FLAG(C, FLAG_C, (v AND 0x01) != 0)
    out := ((v >> 1) OR (oldC << 7)) AND 0xFF
    SET_ZN(C, out)
    RETURN out
END

# ---- BIT test ---------------------------------------------
FUNCTION OP_BIT(C: CPU, val: u8):
    # Z = (A & val)==0; N = val bit7; V = val bit6
    SET_FLAG(C, FLAG_Z, ((C.A AND val) AND 0xFF) == 0)
    SET_FLAG(C, FLAG_N, (val AND 0x80) != 0)
    SET_FLAG(C, FLAG_V, (val AND 0x40) != 0)
END

# ---- INC/DEC memory ---------------------------------------
FUNCTION OP_INC(C: CPU, addr: u16):
    new := (READ8(addr) + 1) AND 0xFF
    WRITE8(addr, new)
    SET_ZN(C, new)
END

FUNCTION OP_DEC(C: CPU, addr: u16):
    new := (READ8(addr) - 1) AND 0xFF
    WRITE8(addr, new)
    SET_ZN(C, new)
END

# ---- Register transfers & inc/dec -------------------------
FUNCTION OP_TAX(C: CPU): C.X := C.A ; SET_ZN(C, C.X) END
FUNCTION OP_TXA(C: CPU): C.A := C.X ; SET_ZN(C, C.A) END
FUNCTION OP_TAY(C: CPU): C.Y := C.A ; SET_ZN(C, C.Y) END
FUNCTION OP_TYA(C: CPU): C.A := C.Y ; SET_ZN(C, C.A) END
FUNCTION OP_TSX(C: CPU): C.X := C.SP ; SET_ZN(C, C.X) END
FUNCTION OP_TXS(C: CPU): C.SP := C.X END
FUNCTION OP_INX(C: CPU): C.X := (C.X + 1) AND 0xFF ; SET_ZN(C, C.X) END
FUNCTION OP_INY(C: CPU): C.Y := (C.Y + 1) AND 0xFF ; SET_ZN(C, C.Y) END
FUNCTION OP_DEX(C: CPU): C.X := (C.X - 1) AND 0xFF ; SET_ZN(C, C.X) END
FUNCTION OP_DEY(C: CPU): C.Y := (C.Y - 1) AND 0xFF ; SET_ZN(C, C.Y) END

# ---- Compare ------------------------------------------------
FUNCTION OP_CMP(C: CPU, val: u8): DO_CMP(C, C.A, val) END
FUNCTION OP_CPX(C: CPU, val: u8): DO_CMP(C, C.X, val) END
FUNCTION OP_CPY(C: CPU, val: u8): DO_CMP(C, C.Y, val) END

# ---- Flags --------------------------------------------------
FUNCTION OP_CLC(C: CPU): SET_FLAG(C, FLAG_C, false) END
FUNCTION OP_SEC(C: CPU): SET_FLAG(C, FLAG_C, true ) END
FUNCTION OP_CLD(C: CPU): SET_FLAG(C, FLAG_D, false) END
FUNCTION OP_SED(C: CPU): SET_FLAG(C, FLAG_D, true ) END
FUNCTION OP_CLI(C: CPU): SET_FLAG(C, FLAG_I, false) END
FUNCTION OP_SEI(C: CPU): SET_FLAG(C, FLAG_I, true ) END
FUNCTION OP_CLV(C: CPU): SET_FLAG(C, FLAG_V, false) END
FUNCTION OP_NOP(C: CPU): NOOP END

# ---- Stack & system ----------------------------------------
FUNCTION OP_PHA(C: CPU): PUSH8(C, C.A) END
FUNCTION OP_PLA(C: CPU): C.A := POP8(C) ; SET_ZN(C, C.A) END
FUNCTION OP_PHP(C: CPU):
    # On PHP/BRK, bit 5 is set, B is set.
    val := (C.P OR FLAG_B OR FLAG_X) AND 0xFF
    PUSH8(C, val)
END
FUNCTION OP_PLP(C: CPU):
    val := POP8(C)
    # B is ignored when pulling; bit 5 typically set in emulators for consistency
    C.P := (val OR FLAG_X) AND (NOT FLAG_B)
END

FUNCTION OP_JSR(C: CPU, target: u16):
    # 6502 pushes (PC-1) high then low
    ret := (C.PC - 1) AND 0xFFFF
    PUSH8(C, (ret >> 8) AND 0xFF)
    PUSH8(C, ret AND 0xFF)
    C.PC := target
END

FUNCTION OP_RTS(C: CPU):
    lo := POP8(C) ; hi := POP8(C)
    C.PC := (((hi << 8) OR lo) + 1) AND 0xFFFF
END

FUNCTION OP_RTI(C: CPU):
    # Pull P (with B ignored) and PC (lo then hi)
    p := POP8(C)
    C.P := (p OR FLAG_X) AND (NOT FLAG_B)
    lo := POP8(C) ; hi := POP8(C)
    C.PC := ((hi << 8) OR lo)
END

FUNCTION OP_BRK(C: CPU):
    # BRK behaves like a forced IRQ with B=1; pushes PC+1
    C.PC := (C.PC + 1) AND 0xFFFF
    PUSH8(C, (C.PC >> 8) AND 0xFF)
    PUSH8(C,  C.PC       AND 0xFF)
    PUSH8(C, (C.P OR FLAG_B OR FLAG_X))
    SET_FLAG(C, FLAG_I, true)
    C.PC := READ16(VEC_IRQ)
END

FUNCTION OP_JMP(C: CPU, target: u16):
    C.PC := target
END

# ---- Branch helper -----------------------------------------
# Returns extra cycles (0,1,2) based on taken and page crossing rules.
FUNCTION DO_BRANCH(C: CPU, cond: bool, target: u16) RETURNS u8:
    IF NOT cond: RETURN 0
    base_page := PAGE(C.PC)
    C.PC := target
    IF PAGE(target) != base_page: RETURN 2   # +1 for taken, +1 for page cross
    ELSE: RETURN 1
    END
END



##############################################################
# SECTION 7 — OPCODE TABLE (mnemonic + addressing mode)
##############################################################
# We maintain a 256-entry DISPATCH[].
# Each entry has: mnemonic (string or enum), mode (string), handler category.
#
# For brevity and fidelity, we directly encode the official set
# (151 valid opcodes) gleaned from your TSV. Undefined opcodes trap.

STRUCT OpInfo:
    mnemonic : string
    mode     : string

ARRAY DISPATCH[0..255] : OpInfo

# Helper to register:
PROCEDURE DEF(ophex: u8, mnem: string, mode: string):
    DISPATCH[ophex] := OpInfo(mnem, mode)
END

# Initialize with the standard table (from 6502-instrs.tsv).
# (Lines in ascending opcode order; undefined slots left as empty/illegal.)
PROCEDURE INIT_DISPATCH_TABLE():
    DEF(0x00,"BRK","impl")
    DEF(0x01,"ORA","X,ind")
    DEF(0x05,"ORA","zpg")
    DEF(0x06,"ASL","zpg")
    DEF(0x08,"PHP","impl")
    DEF(0x09,"ORA","#")
    DEF(0x0A,"ASL","A")
    DEF(0x0D,"ORA","abs")
    DEF(0x0E,"ASL","abs")

    DEF(0x10,"BPL","rel")
    DEF(0x11,"ORA","ind,Y")
    DEF(0x15,"ORA","zpg,X")
    DEF(0x16,"ASL","zpg,X")
    DEF(0x18,"CLC","impl")
    DEF(0x19,"ORA","abs,Y")
    DEF(0x1D,"ORA","abs,X")
    DEF(0x1E,"ASL","abs,X")

    DEF(0x20,"JSR","abs")
    DEF(0x21,"AND","X,ind")
    DEF(0x24,"BIT","zpg")
    DEF(0x25,"AND","zpg")
    DEF(0x26,"ROL","zpg")
    DEF(0x28,"PLP","impl")
    DEF(0x29,"AND","#")
    DEF(0x2A,"ROL","A")
    DEF(0x2C,"BIT","abs")
    DEF(0x2D,"AND","abs")
    DEF(0x2E,"ROL","abs")

    DEF(0x30,"BMI","rel")
    DEF(0x31,"AND","ind,Y")
    DEF(0x35,"AND","zpg,X")
    DEF(0x36,"ROL","zpg,X")
    DEF(0x38,"SEC","impl")
    DEF(0x39,"AND","abs,Y")
    DEF(0x3D,"AND","abs,X")
    DEF(0x3E,"ROL","abs,X")

    DEF(0x40,"RTI","impl")
    DEF(0x41,"EOR","X,ind")
    DEF(0x45,"EOR","zpg")
    DEF(0x46,"LSR","zpg")
    DEF(0x48,"PHA","impl")
    DEF(0x49,"EOR","#")
    DEF(0x4A,"LSR","A")
    DEF(0x4C,"JMP","abs")
    DEF(0x4D,"EOR","abs")
    DEF(0x4E,"LSR","abs")

    DEF(0x50,"BVC","rel")
    DEF(0x51,"EOR","ind,Y")
    DEF(0x55,"EOR","zpg,X")
    DEF(0x56,"LSR","zpg,X")
    DEF(0x58,"CLI","impl")
    DEF(0x59,"EOR","abs,Y")
    DEF(0x5D,"EOR","abs,X")
    DEF(0x5E,"LSR","abs,X")

    DEF(0x60,"RTS","impl")
    DEF(0x61,"ADC","X,ind")
    DEF(0x65,"ADC","zpg")
    DEF(0x66,"ROR","zpg")
    DEF(0x68,"PLA","impl")
    DEF(0x69,"ADC","#")
    DEF(0x6A,"ROR","A")
    DEF(0x6C,"JMP","ind")
    DEF(0x6D,"ADC","abs")
    DEF(0x6E,"ROR","abs")

    DEF(0x70,"BVS","rel")
    DEF(0x71,"ADC","ind,Y")
    DEF(0x75,"ADC","zpg,X")
    DEF(0x76,"ROR","zpg,X")
    DEF(0x78,"SEI","impl")
    DEF(0x79,"ADC","abs,Y")
    DEF(0x7D,"ADC","abs,X")
    DEF(0x7E,"ROR","abs,X")

    DEF(0x81,"STA","X,ind")
    DEF(0x84,"STY","zpg")
    DEF(0x85,"STA","zpg")
    DEF(0x86,"STX","zpg")
    DEF(0x88,"DEY","impl")
    DEF(0x8A,"TXA","impl")
    DEF(0x8C,"STY","abs")
    DEF(0x8D,"STA","abs")
    DEF(0x8E,"STX","abs")

    DEF(0x90,"BCC","rel")
    DEF(0x91,"STA","ind,Y")
    DEF(0x94,"STY","zpg,X")
    DEF(0x95,"STA","zpg,X")
    DEF(0x96,"STX","zpg,Y")
    DEF(0x98,"TYA","impl")
    DEF(0x99,"STA","abs,Y")
    DEF(0x9A,"TXS","impl")
    DEF(0x9D,"STA","abs,X")

    DEF(0xA0,"LDY","#")
    DEF(0xA1,"LDA","X,ind")
    DEF(0xA2,"LDX","#")
    DEF(0xA4,"LDY","zpg")
    DEF(0xA5,"LDA","zpg")
    DEF(0xA6,"LDX","zpg")
    DEF(0xA8,"TAY","impl")
    DEF(0xA9,"LDA","#")
    DEF(0xAA,"TAX","impl")
    DEF(0xAC,"LDY","abs")
    DEF(0xAD,"LDA","abs")
    DEF(0xAE,"LDX","abs")

    DEF(0xB0,"BCS","rel")
    DEF(0xB1,"LDA","ind,Y")
    DEF(0xB4,"LDY","zpg,X")
    DEF(0xB5,"LDA","zpg,X")
    DEF(0xB6,"LDX","zpg,Y")
    DEF(0xB8,"CLV","impl")
    DEF(0xB9,"LDA","abs,Y")
    DEF(0xBA,"TSX","impl")
    DEF(0xBC,"LDY","abs,X")
    DEF(0xBD,"LDA","abs,X")
    DEF(0xBE,"LDX","abs,Y")

    DEF(0xC0,"CPY","#")
    DEF(0xC1,"CMP","X,ind")
    DEF(0xC4,"CPY","zpg")
    DEF(0xC5,"CMP","zpg")
    DEF(0xC6,"DEC","zpg")
    DEF(0xC8,"INY","impl")
    DEF(0xC9,"CMP","#")
    DEF(0xCA,"DEX","impl")
    DEF(0xCC,"CPY","abs")
    DEF(0xCD,"CMP","abs")
    DEF(0xCE,"DEC","abs")

    DEF(0xD0,"BNE","rel")
    DEF(0xD1,"CMP","ind,Y")
    DEF(0xD5,"CMP","zpg,X")
    DEF(0xD6,"DEC","zpg,X")
    DEF(0xD8,"CLD","impl")
    DEF(0xD9,"CMP","abs,Y")
    DEF(0xDD,"CMP","abs,X")
    DEF(0xDE,"DEC","abs,X")

    DEF(0xE0,"CPX","#")
    DEF(0xE1,"SBC","X,ind")
    DEF(0xE4,"CPX","zpg")
    DEF(0xE5,"SBC","zpg")
    DEF(0xE6,"INC","zpg")
    DEF(0xE8,"INX","impl")
    DEF(0xE9,"SBC","#")
    DEF(0xEA,"NOP","impl")
    DEF(0xEC,"CPX","abs")
    DEF(0xED,"SBC","abs")
    DEF(0xEE,"INC","abs")

    DEF(0xF0,"BEQ","rel")
    DEF(0xF1,"SBC","ind,Y")
    DEF(0xF5,"SBC","zpg,X")
    DEF(0xF6,"INC","zpg,X")
    DEF(0xF8,"SED","impl")
    DEF(0xF9,"SBC","abs,Y")
    DEF(0xFD,"SBC","abs,X")
    DEF(0xFE,"INC","abs,X")
END



#########################################################
# SECTION 8 — FETCH/DECODE/EXECUTE: MAIN INTERPRETER
#########################################################
# Addressing mode dispatcher to resolver:
FUNCTION RESOLVE(mode: string, C: CPU) RETURNS (kind, addr, val, crossed):
    SWITCH mode:
        CASE "impl":  RETURN AM_IMPL(C)
        CASE "A":     RETURN AM_ACC(C)
        CASE "#":     RETURN AM_IMM(C)
        CASE "zpg":   RETURN AM_ZP(C)
        CASE "zpg,X": RETURN AM_ZPX(C)
        CASE "zpg,Y": RETURN AM_ZPY(C)
        CASE "abs":   RETURN AM_ABS(C)
        CASE "abs,X": RETURN AM_ABX(C)
        CASE "abs,Y": RETURN AM_ABY(C)
        CASE "ind":   RETURN AM_IND(C)
        CASE "X,ind": RETURN AM_XIND(C)
        CASE "ind,Y": RETURN AM_INDY(C)
        CASE "rel":   RETURN AM_REL(C)
        DEFAULT: ABORT("unknown mode")
    END
END

# Execute a single decoded instruction; returns cycles consumed.
FUNCTION EXECUTE_ONE(C: CPU, mnem: string, mode: string) RETURNS u8:
    # Service pending interrupts before executing the next instruction
    IF C.pending_NMI:
        C.pending_NMI := false
        # NMI push PCH,PCL,P |B=0|, set I=1, jump to $FFFA
        PUSH8(C, (C.PC >> 8) AND 0xFF)
        PUSH8(C,  C.PC       AND 0xFF)
        PUSH8(C, (C.P AND (NOT FLAG_B)) OR FLAG_X)
        SET_FLAG(C, FLAG_I, true)
        C.PC := READ16(VEC_NMI)
        RETURN 7    # NMI timing commonly 7 cycles (like BRK/IRQ path)
    END
    IF C.pending_IRQ AND (NOT GET_FLAG(C, FLAG_I)):
        C.pending_IRQ := false
        PUSH8(C, (C.PC >> 8) AND 0xFF)
        PUSH8(C,  C.PC       AND 0xFF)
        PUSH8(C, (C.P AND (NOT FLAG_B)) OR FLAG_X)
        SET_FLAG(C, FLAG_I, true)
        C.PC := READ16(VEC_IRQ)
        RETURN 7
    END

    # Decode addressing/operands
    (kind, addr, val, crossed) := RESOLVE(mode, C)

    (base_cycles, adds_on_cross) := CYCLES_BASE(mnem, mode)
    extra := 0

    # Now execute per mnemonic:
    SWITCH mnem:

        # Branches
        CASE "BPL": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_N)==false, addr) ; RETURN base_cycles + extra
        CASE "BMI": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_N)==true , addr) ; RETURN base_cycles + extra
        CASE "BVC": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_V)==false, addr) ; RETURN base_cycles + extra
        CASE "BVS": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_V)==true , addr) ; RETURN base_cycles + extra
        CASE "BCC": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_C)==false, addr) ; RETURN base_cycles + extra
        CASE "BCS": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_C)==true , addr) ; RETURN base_cycles + extra
        CASE "BNE": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_Z)==false, addr) ; RETURN base_cycles + extra
        CASE "BEQ": extra := DO_BRANCH(C, GET_FLAG(C, FLAG_Z)==true , addr) ; RETURN base_cycles + extra

        # Jumps/JSR/RTS/RTI
        CASE "JMP": OP_JMP(C, addr) ; RETURN base_cycles
        CASE "JSR": OP_JSR(C, addr) ; RETURN base_cycles
        CASE "RTS": OP_RTS(C)       ; RETURN base_cycles
        CASE "RTI": OP_RTI(C)       ; RETURN base_cycles

        # BRK
        CASE "BRK": OP_BRK(C)       ; RETURN base_cycles

        # Loads (addressing may be immediate or memory)
        CASE "LDA":
            IF kind == "#": OP_LDA(C, val) ELSE: OP_LDA(C, READ8(addr)) END
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)
        CASE "LDX":
            v := (kind == "#") ? val : READ8(addr)
            OP_LDX(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)
        CASE "LDY":
            v := (kind == "#") ? val : READ8(addr)
            OP_LDY(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)

        # Stores
        CASE "STA": OP_STA(C, addr) ; RETURN base_cycles
        CASE "STX": OP_STX(C, addr) ; RETURN base_cycles
        CASE "STY": OP_STY(C, addr) ; RETURN base_cycles

        # Logical/Arithmetic
        CASE "AND":
            v := (kind == "#") ? val : READ8(addr)
            OP_AND(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)
        CASE "ORA":
            v := (kind == "#") ? val : READ8(addr)
            OP_ORA(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)
        CASE "EOR":
            v := (kind == "#") ? val : READ8(addr)
            OP_EOR(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)
        CASE "ADC":
            v := (kind == "#") ? val : READ8(addr)
            OP_ADC(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)
        CASE "SBC":
            v := (kind == "#") ? val : READ8(addr)
            OP_SBC(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)

        # Shifts/Rotates (A vs memory)
        CASE "ASL":
            IF kind == "A": C.A := SH_ASL(C, C.A)
            ELSE: RMW(C, addr, (x)->SH_ASL(C,x))
            END
            RETURN base_cycles
        CASE "LSR":
            IF kind == "A": C.A := SH_LSR(C, C.A)
            ELSE: RMW(C, addr, (x)->SH_LSR(C,x))
            END
            RETURN base_cycles
        CASE "ROL":
            IF kind == "A": C.A := SH_ROL(C, C.A)
            ELSE: RMW(C, addr, (x)->SH_ROL(C,x))
            END
            RETURN base_cycles
        CASE "ROR":
            IF kind == "A": C.A := SH_ROR(C, C.A)
            ELSE: RMW(C, addr, (x)->SH_ROR(C,x))
            END
            RETURN base_cycles

        # BIT
        CASE "BIT": OP_BIT(C, READ8(addr)) ; RETURN base_cycles

        # INC/DEC memory
        CASE "INC": OP_INC(C, addr) ; RETURN base_cycles
        CASE "DEC": OP_DEC(C, addr) ; RETURN base_cycles

        # Register ops & flags
        CASE "TAX": OP_TAX(C) ; RETURN base_cycles
        CASE "TXA": OP_TXA(C) ; RETURN base_cycles
        CASE "TAY": OP_TAY(C) ; RETURN base_cycles
        CASE "TYA": OP_TYA(C) ; RETURN base_cycles
        CASE "TSX": OP_TSX(C) ; RETURN base_cycles
        CASE "TXS": OP_TXS(C) ; RETURN base_cycles
        CASE "DEX": OP_DEX(C) ; RETURN base_cycles
        CASE "DEY": OP_DEY(C) ; RETURN base_cycles
        CASE "INX": OP_INX(C) ; RETURN base_cycles
        CASE "INY": OP_INY(C) ; RETURN base_cycles

        CASE "CMP":
            v := (kind == "#") ? val : READ8(addr)
            OP_CMP(C, v)
            RETURN base_cycles + (adds_on_cross AND crossed ? 1 : 0)
        CASE "CPX":
            v := (kind == "#") ? val : READ8(addr)
            OP_CPX(C, v)
            RETURN base_cycles
        CASE "CPY":
            v := (kind == "#") ? val : READ8(addr)
            OP_CPY(C, v)
            RETURN base_cycles

        CASE "CLC": OP_CLC(C) ; RETURN base_cycles
        CASE "SEC": OP_SEC(C) ; RETURN base_cycles
        CASE "CLI": OP_CLI(C) ; RETURN base_cycles
        CASE "SEI": OP_SEI(C) ; RETURN base_cycles
        CASE "CLV": OP_CLV(C) ; RETURN base_cycles
        CASE "CLD": OP_CLD(C) ; RETURN base_cycles
        CASE "SED": OP_SED(C) ; RETURN base_cycles
        CASE "NOP": OP_NOP(C) ; RETURN base_cycles

        DEFAULT:
            ABORT("Illegal/unsupported opcode mnemonic: " + mnem)
    END
END

# Fetch/decode step: returns cycles for the instruction.
FUNCTION STEP(C: CPU) RETURNS u8:
    opcode := READ8(C.PC) ; C.PC := (C.PC + 1) AND 0xFFFF
    info := DISPATCH[opcode]
    IF info.mnemonic IS EMPTY:
        ABORT("Illegal opcode $" + HEX2(opcode) + " at PC $" + HEX4((C.PC-1) AND 0xFFFF))
    END
    return EXECUTE_ONE(C, info.mnemonic, info.mode)
END



###################################################
# SECTION 9 — RESET/INTERRUPTS & MAIN RUN LOOP
###################################################
PROCEDURE CPU_RESET(C: CPU):
    C.A := 0 ; C.X := 0 ; C.Y := 0
    C.SP := 0xFD
    C.P  := (FLAG_I OR FLAG_X)    # I=1, bit5=1, others 0
    C.PC := READ16(VEC_RESET)
    C.cycles := 0
    C.running := true
    C.pending_IRQ := false
    C.pending_NMI := false
END

PROCEDURE SIGNAL_NMI(C: CPU): C.pending_NMI := true END
PROCEDURE SIGNAL_IRQ(C: CPU): C.pending_IRQ := true END

# Run for 'budget' cycles (or forever if budget==0)
PROCEDURE RUN(C: CPU, budget: u64):
    WHILE C.running:
        used := STEP(C)
        C.cycles := C.cycles + used
        IF budget != 0 AND C.cycles >= budget: BREAK END
    END
END



###############################################################
# SECTION 10 — BINARY LOADER (INTERFACE FOR MACHINE CODE)
###############################################################
# Two simple loading APIs:
#   (1) LOAD_BINARY_AT(bytes, start_addr)
#   (2) LOAD_PRG_AUTOSTART(bytes) for Commodore-style 2-byte load address

PROCEDURE LOAD_BINARY_AT(bytes: ARRAY<u8>, start_addr: u16):
    FOR i FROM 0 TO (LEN(bytes)-1):
        WRITE8((start_addr + i) AND 0xFFFF, bytes[i])
    END
END

# If 'bytes' begins with a 16-bit little-endian load address ($LL,$HH),
# place the remaining bytes at that address and set PC to the same (optionally).
PROCEDURE LOAD_PRG_AUTOSTART(C: CPU, bytes: ARRAY<u8>, set_PC: bool):
    IF LEN(bytes) < 2: ABORT("PRG too short") END
    load := (bytes[1] << 8) OR bytes[0]
    FOR i FROM 2 TO (LEN(bytes)-1):
        WRITE8((load + (i-2)) AND 0xFFFF, bytes[i])
    END
    IF set_PC: C.PC := load END
END



###############################################################
# SECTION 11 — POWER-ON SEQUENCE (EXAMPLE USAGE)
###############################################################
# Example (illustrative):
#
#   INIT_DISPATCH_TABLE()
#   CPU_RESET(cpu)
#   LOAD_BINARY_AT(program_bytes, 0x0600)
#   WRITE8(0xFFFC, 0x00) ; WRITE8(0xFFFD, 0x06)   # reset vector -> $0600
#   RUN(cpu, budget=0)    # run forever (or give a cycle budget)

PROCEDURE POWER_ON_AND_RUN(program_bytes: ARRAY<u8>, reset_to: u16, cycles_budget: u64):
    INIT_DISPATCH_TABLE()
    CPU_RESET(cpu)
    LOAD_BINARY_AT(program_bytes, reset_to)
    WRITE8(VEC_RESET + 0, (reset_to AND 0xFF))
    WRITE8(VEC_RESET + 1, ((reset_to >> 8) AND 0xFF))
    RUN(cpu, cycles_budget)
END



#################################################################
# APPENDIX — SANITY NOTES & EDGE-CASE BEHAVIOR CAPTURED ABOVE
#################################################################
# • $JMP (ind)$ implements the original NMOS wrap bug: high byte read wraps within page.
# • Branch timing: base 2 cycles +1 if taken +1 more if destination crosses a page.
# • Page-cross penalties apply only on the documented opcodes/modes as encoded in CYCLES_BASE().
# • Decimal (BCD) mode affects only ADC/SBC; V flag mirrors the binary add/sub behavior.
# • BRK sets B when pushing P; PLP ignores B when pulling (we preserve bit 5 set).
# • Interrupt entry pushes PC and P (with B=0 on IRQ/NMI), sets I=1, and vectors to $FFFA$ (NMI) or $FFFE$ (IRQ/BRK).
# • RESET loads PC from $FFFC$, sets I=1, SP=$FD$ (common power-on state).
# • Stack is on page $1$; helpers PUSH*/POP* address $0x0100|SP$.
# • All arithmetic & loads set Z/N per official rules; compares set C as (reg >= mem).
# • Unimplemented/illegal opcodes trap with a clear message; extendable if you want NMOS "undocumented" set later.

