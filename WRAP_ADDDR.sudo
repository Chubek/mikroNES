############################################################
#  NES MEMORY ADDRESS WRAPPING FUNCTION                    #
#  Maps raw 16-bit CPU addresses to correct memory regions #
############################################################

# NES Memory Map Constants
CONST ADDR_RAM_START       = 0x0000
CONST ADDR_RAM_END         = 0x1FFF
CONST ADDR_PPU_START       = 0x2000
CONST ADDR_PPU_END         = 0x3FFF
CONST ADDR_APU_IO_START    = 0x4000
CONST ADDR_APU_IO_END      = 0x401F
CONST ADDR_CART_START      = 0x4020
CONST ADDR_CART_END        = 0xFFFF

# Internal RAM mirrors
CONST RAM_SIZE             = 0x0800  # 2KB internal RAM
CONST RAM_MIRROR_MASK      = 0x07FF  # Mask to wrap 0x0000-0x1FFF to 2KB

# PPU register mirrors
CONST PPU_REG_SIZE         = 0x0008  # 8 PPU registers
CONST PPU_MIRROR_MASK      = 0x2007  # Mask to wrap 0x2000-0x3FFF to 8 registers

FUNCTION wrapaddr_fn(raw_addr: u16) RETURNS u16:
    # Apply address mask to handle wraparound
    raw_addr := raw_addr AND 0xFFFF
    
    # Handle different memory regions
    IF raw_addr <= ADDR_RAM_END:
        # Internal RAM ($0000-$1FFF) - mirrored every 2KB
        RETURN raw_addr AND RAM_MIRROR_MASK
        
    ELIF raw_addr >= ADDR_PPU_START AND raw_addr <= ADDR_PPU_END:
        # PPU Registers ($2000-$3FFF) - mirrored every 8 bytes
        base_offset := raw_addr - ADDR_PPU_START
        register_index := base_offset AND (PPU_REG_SIZE - 1)
        RETURN ADDR_PPU_START + register_index
        
    ELIF raw_addr >= ADDR_APU_IO_START AND raw_addr <= ADDR_APU_IO_END:
        # APU & I/O Registers ($4000-$401F) - no mirroring
        # Some addresses have special behavior but are not mirrored
        RETURN raw_addr
        
    ELIF raw_addr == 0x4014:
        # OAM DMA Register - special case
        RETURN raw_addr
        
    ELIF raw_addr == 0x4016 OR raw_addr == 0x4017:
        # Controller Ports - special cases
        RETURN raw_addr
        
    ELIF raw_addr >= ADDR_CART_START:
        # Cartridge Space ($4020-$FFFF)
        # This area is handled by the mapper and can be bank-switched
        # For now, return as-is but in a real emulator this would
        # depend on the mapper type and current bank configuration
        RETURN raw_addr
        
    ELSE:
        # Should not happen with 16-bit addresses, but for completeness
        RETURN raw_addr
    END
END

# Example usage in memory access functions:
FUNCTION READ_MEMORY(addr: u16) RETURNS u8:
    mapped_addr := wrapaddr_fn(addr)
    
    # Handle special memory-mapped I/O
    IF mapped_addr >= ADDR_PPU_START AND mapped_addr <= (ADDR_PPU_START + 7):
        RETURN READ_PPU_REGISTER(mapped_addr)
        
    ELIF mapped_addr == 0x4016 OR mapped_addr == 0x4017:
        RETURN READ_CONTROLLER(mapped_addr)  # Assume this function exists
        
    ELIF mapped_addr >= ADDR_APU_IO_START AND mapped_addr <= ADDR_APU_IO_END:
        RETURN READ_APU_REGISTER(mapped_addr)  # Assume this function exists
        
    ELIF mapped_addr <= ADDR_RAM_END:
        RETURN MEMORY[mapped_addr]  # Internal RAM access
        
    ELIF mapped_addr >= ADDR_CART_START:
        RETURN READ_CARTRIDGE_MEMORY(mapped_addr)  # Mapper-dependent
        
    ELSE:
        RETURN 0  # Default return for unmapped addresses
    END
END

FUNCTION WRITE_MEMORY(addr: u16, value: u8):
    mapped_addr := wrapaddr_fn(addr)
    value := value AND 0xFF
    
    # Handle special memory-mapped I/O
    IF mapped_addr >= ADDR_PPU_START AND mapped_addr <= (ADDR_PPU_START + 7):
        WRITE_PPU_REGISTER(mapped_addr, value)
        RETURN
        
    ELIF mapped_addr == 0x4014:
        PERFORM_OAM_DMA(value)  # Assume this function exists
        RETURN
        
    ELIF mapped_addr == 0x4016:
        WRITE_CONTROLLER_STROBE(value)  # Assume this function exists
        RETURN
        
    ELIF mapped_addr >= ADDR_APU_IO_START AND mapped_addr <= ADDR_APU_IO_END:
        WRITE_APU_REGISTER(mapped_addr, value)  # Assume this function exists
        RETURN
        
    ELIF mapped_addr <= ADDR_RAM_END:
        MEMORY[mapped_addr] := value  # Internal RAM access
        RETURN
        
    ELIF mapped_addr >= ADDR_CART_START:
        WRITE_CARTRIDGE_MEMORY(mapped_addr, value)  # Mapper-dependent
        RETURN
        
    END
    # Writes to read-only areas (like PPU registers other than $2000-$2007) are ignored
END

