# APU.sudo - NES Audio Processing Unit Emulation
# Implements the RP2A03 (NTSC) / RP2A07 (PAL) audio functionality

IMPORT AudioLib  # Generic audio library interface

# ============================================================================
# CONSTANTS
# ============================================================================

CONST CPU_FREQ_NTSC: u32 = 1789773  # Hz
CONST CPU_FREQ_PAL: u32 = 1662607   # Hz
CONST SAMPLE_RATE: u32 = 44100      # Output sample rate

# Channel enable bits for $4015
CONST DMC_ENABLE: u8 = 0x10
CONST NOISE_ENABLE: u8 = 0x08
CONST TRIANGLE_ENABLE: u8 = 0x04
CONST PULSE2_ENABLE: u8 = 0x02
CONST PULSE1_ENABLE: u8 = 0x01

# Frame counter modes
CONST MODE_4_STEP: u8 = 0
CONST MODE_5_STEP: u8 = 1

# ============================================================================
# DATA STRUCTURES
# ============================================================================

STRUCT Envelope
    start_flag: bool
    loop_flag: bool
    constant_volume_flag: bool
    divider_period: u8
    divider_counter: u8
    decay_level: u8
    volume: u8
END

STRUCT Sweep
    enabled: bool
    period: u8
    negate: bool
    shift: u8
    divider: u8
    reload_flag: bool
    target_period: u16
END

STRUCT LengthCounter
    halt: bool
    value: u8
END

STRUCT LinearCounter
    control_flag: bool
    reload_value: u8
    counter: u8
    reload_flag: bool
END

STRUCT Timer
    period: u16
    counter: u16
END

STRUCT PulseChannel
    enabled: bool
    duty_cycle: u8
    duty_position: u8
    timer: Timer
    envelope: Envelope
    sweep: Sweep
    length_counter: LengthCounter
    output: u8
END

STRUCT TriangleChannel
    enabled: bool
    timer: Timer
    length_counter: LengthCounter
    linear_counter: LinearCounter
    step_counter: u8
    output: u8
END

STRUCT NoiseChannel
    enabled: bool
    mode: bool  # false = normal, true = periodic
    timer: Timer
    envelope: Envelope
    length_counter: LengthCounter
    shift_register: u16
    output: u8
END

STRUCT DMCChannel
    enabled: bool
    irq_enabled: bool
    loop: bool
    frequency_index: u8
    direct_load: u8
    sample_address: u16
    sample_length: u16
    current_address: u16
    bytes_remaining: u16
    sample_buffer: u8
    sample_buffer_empty: bool
    shift_register: u8
    bits_remaining: u8
    output: u8
    interrupt_flag: bool
END

STRUCT FrameCounter
    mode: u8  # 4-step or 5-step
    irq_inhibit: bool
    step: u8
    divider: u16
    interrupt_flag: bool
END

STRUCT APU
    pulse1: PulseChannel
    pulse2: PulseChannel
    triangle: TriangleChannel
    noise: NoiseChannel
    dmc: DMCChannel
    frame_counter: FrameCounter
    
    cpu_frequency: u32
    cycles_per_sample: f32
    cycle_counter: f32
    
    # Audio output
    audio_buffer: ARRAY[f32, 2048]
    buffer_position: u16
    audio_device: AudioDevice  # From AudioLib
END

# ============================================================================
# LOOKUP TABLES
# ============================================================================

CONST LENGTH_TABLE: ARRAY[u8, 32] = [
    10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14,
    12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30
]

CONST DUTY_SEQUENCES: ARRAY[ARRAY[u8, 8], 4] = [
    [0, 1, 0, 0, 0, 0, 0, 0],  # 12.5%
    [0, 1, 1, 0, 0, 0, 0, 0],  # 25%
    [0, 1, 1, 1, 1, 0, 0, 0],  # 50%
    [1, 0, 0, 1, 1, 1, 1, 1]   # 75% (negated 25%)
]

CONST TRIANGLE_SEQUENCE: ARRAY[u8, 32] = [
    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
]

CONST NOISE_PERIOD_TABLE: ARRAY[u16, 16] = [
    4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068
]

CONST DMC_RATE_TABLE_NTSC: ARRAY[u16, 16] = [
    428, 380, 340, 320, 286, 254, 226, 214, 190, 160, 142, 128, 106, 84, 72, 54
]

CONST DMC_RATE_TABLE_PAL: ARRAY[u16, 16] = [
    398, 354, 316, 298, 276, 236, 210, 198, 176, 148, 132, 118, 98, 78, 66, 50
]

# ============================================================================
# APU INITIALIZATION
# ============================================================================

FUNCTION apu_create(cpu_freq: u32) -> APU
    VAR apu: APU
    
    apu.cpu_frequency = cpu_freq
    apu.cycles_per_sample = CAST(f32, cpu_freq) / CAST(f32, SAMPLE_RATE)
    apu.cycle_counter = 0.0
    
    # Initialize audio output
    apu.audio_device = AudioLib.create_device(SAMPLE_RATE, 1, 2048)
    apu.buffer_position = 0
    
    # Initialize channels to default state
    apu.pulse1.shift_register = 1
    apu.pulse2.shift_register = 1
    apu.noise.shift_register = 1
    
    # Set frame counter to 4-step mode
    apu.frame_counter.mode = MODE_4_STEP
    apu.frame_counter.step = 0
    
    RETURN apu
END

# ============================================================================
# REGISTER WRITES
# ============================================================================

FUNCTION apu_write_register(apu: PTR[APU], address: u16, value: u8)
    IF address >= 0x4000 AND address <= 0x4017 THEN
        SWITCH address
            CASE 0x4000:  # Pulse 1 control
                write_pulse_control(PTR[apu.pulse1], value)
            
            CASE 0x4001:  # Pulse 1 sweep
                write_pulse_sweep(PTR[apu.pulse1], value, 1)
            
            CASE 0x4002:  # Pulse 1 timer low
                apu.pulse1.timer.period = (apu.pulse1.timer.period AND 0xFF00) OR value
            
            CASE 0x4003:  # Pulse 1 timer high + length
                write_pulse_timer_high(PTR[apu.pulse1], value)
            
            CASE 0x4004:  # Pulse 2 control
                write_pulse_control(PTR[apu.pulse2], value)
            
            CASE 0x4005:  # Pulse 2 sweep
                write_pulse_sweep(PTR[apu.pulse2], value, 2)
            
            CASE 0x4006:  # Pulse 2 timer low
                apu.pulse2.timer.period = (apu.pulse2.timer.period AND 0xFF00) OR value
            
            CASE 0x4007:  # Pulse 2 timer high + length
                write_pulse_timer_high(PTR[apu.pulse2], value)
            
            CASE 0x4008:  # Triangle control
                write_triangle_control(PTR[apu.triangle], value)
            
            CASE 0x400A:  # Triangle timer low
                apu.triangle.timer.period = (apu.triangle.timer.period AND 0xFF00) OR value
            
            CASE 0x400B:  # Triangle timer high + length
                write_triangle_timer_high(PTR[apu.triangle], value)
            
            CASE 0x400C:  # Noise control
                write_noise_control(PTR[apu.noise], value)
            
            CASE 0x400E:  # Noise period
                write_noise_period(PTR[apu.noise], value)
            
            CASE 0x400F:  # Noise length
                write_noise_length(PTR[apu.noise], value)
            
            CASE 0x4010:  # DMC control
                write_dmc_control(PTR[apu.dmc], value)
            
            CASE 0x4011:  # DMC direct load
                apu.dmc.direct_load = value AND 0x7F
                apu.dmc.output = apu.dmc.direct_load
            
            CASE 0x4012:  # DMC sample address
                apu.dmc.sample_address = 0xC000 OR (CAST(u16, value) << 6)
            
            CASE 0x4013:  # DMC sample length
                apu.dmc.sample_length = (CAST(u16, value) << 4) OR 1
            
            CASE 0x4015:  # Status/Control
                write_status(apu, value)
            
            CASE 0x4017:  # Frame counter
                write_frame_counter(PTR[apu.frame_counter], value)
        END
    END
END

# ============================================================================
# REGISTER READS
# ============================================================================

FUNCTION apu_read_status(apu: PTR[APU]) -> u8
    VAR status: u8 = 0
    
    # Length counter status bits
    IF apu.pulse1.length_counter.value > 0 THEN
        status = status OR PULSE1_ENABLE
    END
    
    IF apu.pulse2.length_counter.value > 0 THEN
        status = status OR PULSE2_ENABLE
    END
    
    IF apu.triangle.length_counter.value > 0 THEN
        status = status OR TRIANGLE_ENABLE
    END
    
    IF apu.noise.length_counter.value > 0 THEN
        status = status OR NOISE_ENABLE
    END
    
    # DMC status
    IF apu.dmc.bytes_remaining > 0 THEN
        status = status OR DMC_ENABLE
    END
    
    # Interrupt flags
    IF apu.frame_counter.interrupt_flag THEN
        status = status OR 0x40
        apu.frame_counter.interrupt_flag = false  # Clear on read
    END
    
    IF apu.dmc.interrupt_flag THEN
        status = status OR 0x80
    END
    
    RETURN status
END

# ============================================================================
# CHANNEL IMPLEMENTATIONS
# ============================================================================

# Pulse channel functions
FUNCTION write_pulse_control(pulse: PTR[PulseChannel], value: u8)
    pulse.duty_cycle = (value >> 6) AND 0x03
    pulse.length_counter.halt = (value AND 0x20) != 0
    pulse.envelope.loop_flag = pulse.length_counter.halt
    pulse.envelope.constant_volume_flag = (value AND 0x10) != 0
    pulse.envelope.volume = value AND 0x0F
    pulse.envelope.divider_period = pulse.envelope.volume
END

FUNCTION write_pulse_sweep(pulse: PTR[PulseChannel], value: u8, channel_num: u8)
    pulse.sweep.enabled = (value AND 0x80) != 0
    pulse.sweep.period = (value >> 4) AND 0x07
    pulse.sweep.negate = (value AND 0x08) != 0
    pulse.sweep.shift = value AND 0x07
    pulse.sweep.reload_flag = true
END

FUNCTION write_pulse_timer_high(pulse: PTR[PulseChannel], value: u8)
    pulse.timer.period = (pulse.timer.period AND 0x00FF) OR (CAST(u16, value AND 0x07) << 8)
    pulse.length_counter.value = LENGTH_TABLE[value >> 3]
    pulse.duty_position = 0  # Reset phase
    pulse.envelope.start_flag = true
END

FUNCTION clock_pulse_timer(pulse: PTR[PulseChannel])
    IF pulse.timer.counter == 0 THEN
        pulse.timer.counter = pulse.timer.period
        pulse.duty_position = (pulse.duty_position + 1) AND 0x07
    ELSE
        pulse.timer.counter = pulse.timer.counter - 1
    END
END

FUNCTION get_pulse_output(pulse: PTR[PulseChannel]) -> u8
    # Check if channel should be silenced
    IF NOT pulse.enabled THEN
        RETURN 0
    END
    
    IF pulse.length_counter.value == 0 THEN
        RETURN 0
    END
    
    # Sweep silence check
    IF pulse.timer.period < 8 OR pulse.sweep.target_period > 0x7FF THEN
        RETURN 0
    END
    
    # Get duty cycle output
    VAR duty_output: u8 = DUTY_SEQUENCES[pulse.duty_cycle][pulse.duty_position]
    
    IF duty_output == 0 THEN
        RETURN 0
    END
    
    # Apply volume/envelope
    IF pulse.envelope.constant_volume_flag THEN
        RETURN pulse.envelope.volume
    ELSE
        RETURN pulse.envelope.decay_level
    END
END

# Triangle channel functions
FUNCTION write_triangle_control(triangle: PTR[TriangleChannel], value: u8)
    triangle.length_counter.halt = (value AND 0x80) != 0
    triangle.linear_counter.control_flag = triangle.length_counter.halt
    triangle.linear_counter.reload_value = value AND 0x7F
END

FUNCTION write_triangle_timer_high(triangle: PTR[TriangleChannel], value: u8)
    triangle.timer.period = (triangle.timer.period AND 0x00FF) OR (CAST(u16, value AND 0x07) << 8)
    triangle.length_counter.value = LENGTH_TABLE[value >> 3]
    triangle.linear_counter.reload_flag = true
END

FUNCTION clock_triangle_timer(triangle: PTR[TriangleChannel])
    IF triangle.timer.counter == 0 THEN
        triangle.timer.counter = triangle.timer.period
        
        # Only advance if both counters are non-zero
        IF triangle.length_counter.value > 0 AND triangle.linear_counter.counter > 0 THEN
            triangle.step_counter = (triangle.step_counter + 1) AND 0x1F
            triangle.output = TRIANGLE_SEQUENCE[triangle.step_counter]
        END
    ELSE
        triangle.timer.counter = triangle.timer.counter - 1
    END
END

# Noise channel functions
FUNCTION write_noise_control(noise: PTR[NoiseChannel], value: u8)
    noise.length_counter.halt = (value AND 0x20) != 0
    noise.envelope.loop_flag = noise.length_counter.halt
    noise.envelope.constant_volume_flag = (value AND 0x10) != 0
    noise.envelope.volume = value AND 0x0F
    noise.envelope.divider_period = noise.envelope.volume
END

FUNCTION write_noise_period(noise: PTR[NoiseChannel], value: u8)
    noise.mode = (value AND 0x80) != 0
    noise.timer.period = NOISE_PERIOD_TABLE[value AND 0x0F]
END

FUNCTION write_noise_length(noise: PTR[NoiseChannel], value: u8)
    noise.length_counter.value = LENGTH_TABLE[value >> 3]
    noise.envelope.start_flag = true
END

FUNCTION clock_noise_timer(noise: PTR[NoiseChannel])
    IF noise.timer.counter == 0 THEN
        noise.timer.counter = noise.timer.period
        
        # Clock LFSR
        VAR feedback: u16
        IF noise.mode THEN
            # Periodic mode - use bit 6
            feedback = (noise.shift_register AND 1) XOR ((noise.shift_register >> 6) AND 1)
        ELSE
            # Normal mode - use bit 1
            feedback = (noise.shift_register AND 1) XOR ((noise.shift_register >> 1) AND 1)
        END
        
        noise.shift_register = noise.shift_register >> 1
        noise.shift_register = noise.shift_register OR (feedback << 14)
    ELSE
        noise.timer.counter = noise.timer.counter - 1
    END
END

FUNCTION get_noise_output(noise: PTR[NoiseChannel]) -> u8
    IF NOT noise.enabled THEN
        RETURN 0
    END
    
    IF noise.length_counter.value == 0 THEN
        RETURN 0
    END
    
    IF (noise.shift_register AND 1) != 0 THEN
        RETURN 0
    END
    
    IF noise.envelope.constant_volume_flag THEN
        RETURN noise.envelope.volume
    ELSE
        RETURN noise.envelope.decay_level
    END
END

# DMC channel functions
FUNCTION write_dmc_control(dmc: PTR[DMCChannel], value: u8)
    dmc.irq_enabled = (value AND 0x80) != 0
    dmc.loop = (value AND 0x40) != 0
    dmc.frequency_index = value AND 0x0F
    
    IF NOT dmc.irq_enabled THEN
        dmc.interrupt_flag = false
    END
END

FUNCTION clock_dmc_timer(dmc: PTR[DMCChannel], cpu_freq: u32)
    # Determine rate table based on system
    VAR rate_table: PTR[ARRAY[u16, 16]]
    IF cpu_freq == CPU_FREQ_NTSC THEN
        rate_table = PTR[DMC_RATE_TABLE_NTSC]
    ELSE
        rate_table = PTR[DMC_RATE_TABLE_PAL]
    END
    
    IF dmc.timer.counter == 0 THEN
        dmc.timer.counter = rate_table[dmc.frequency_index]
        clock_dmc_output(dmc)
    ELSE
        dmc.timer.counter = dmc.timer.counter - 1
    END
END

FUNCTION clock_dmc_output(dmc: PTR[DMCChannel])
    # Output cycle
    IF dmc.bits_remaining > 0 THEN
        IF (dmc.shift_register AND 1) != 0 THEN
            # Increment
            IF dmc.output <= 125 THEN
                dmc.output = dmc.output + 2
            END
        ELSE
            # Decrement
            IF dmc.output >= 2 THEN
                dmc.output = dmc.output - 2
            END
        END
        
        dmc.shift_register = dmc.shift_register >> 1
        dmc.bits_remaining = dmc.bits_remaining - 1
    END
    
    # Sample fetch
    IF dmc.bits_remaining == 0 AND NOT dmc.sample_buffer_empty THEN
        dmc.shift_register = dmc.sample_buffer
        dmc.bits_remaining = 8
        dmc.sample_buffer_empty = true
        
        # Start memory read if bytes remaining
        IF dmc.bytes_remaining > 0 THEN
            # This would trigger actual memory read
            # For now, we'll simulate it
            dmc_fetch_sample(dmc)
        END
    END
END

FUNCTION dmc_fetch_sample(dmc: PTR[DMCChannel])
    # In real emulation, this would read from memory
    # Here we simulate the fetch
    dmc.sample_buffer = 0x55  # Placeholder
    dmc.sample_buffer_empty = false
    
    dmc.current_address = dmc.current_address + 1
    IF dmc.current_address == 0x0000 THEN  # Wrapped around
        dmc.current_address = 0x8000
    END
    
    dmc.bytes_remaining = dmc.bytes_remaining - 1
    
    IF dmc.bytes_remaining == 0 THEN
        IF dmc.loop THEN
            dmc.current_address = dmc.sample_address
            dmc.bytes_remaining = dmc.sample_length
        ELSE IF dmc.irq_enabled THEN
            dmc.interrupt_flag = true
        END
    END
END

# ============================================================================
# FRAME COUNTER
# ============================================================================

FUNCTION write_frame_counter(fc: PTR[FrameCounter], value: u8)
    fc.mode = (value >> 7) AND 1
    fc.irq_inhibit = (value AND 0x40) != 0
    
    IF fc.irq_inhibit THEN
        fc.interrupt_flag = false
    END
    
    # Reset frame counter
    fc.divider = 0
    fc.step = 0
    
    # If 5-step mode, immediately clock
    IF fc.mode == MODE_5_STEP THEN
        clock_envelopes()
        clock_length_counters()
        clock_sweeps()
    END
END

FUNCTION clock_frame_counter(apu: PTR[APU])
    VAR fc: PTR[FrameCounter] = PTR[apu.frame_counter]
    
    # Frame counter runs at 240Hz (CPU / 7457)
    fc.divider = fc.divider + 1
    
    VAR clock_divider: u16
    IF apu.cpu_frequency == CPU_FREQ_NTSC THEN
        clock_divider = 7457
    ELSE
        clock_divider = 7458
    END
    
    IF fc.divider >= clock_divider THEN
        fc.divider = 0
        
        IF fc.mode == MODE_4_STEP THEN
            clock_frame_4_step(apu)
        ELSE
            clock_frame_5_step(apu)
        END
    END
END

FUNCTION clock_frame_4_step(apu: PTR[APU])
    VAR fc: PTR[FrameCounter] = PTR[apu.frame_counter]
    
    SWITCH fc.step
        CASE 0:
            clock_envelopes(apu)
        
        CASE 1:
            clock_envelopes(apu)
            clock_length_counters(apu)
            clock_sweeps(apu)
        
        CASE 2:
            clock_envelopes(apu)
        
        CASE 3:
            clock_envelopes(apu)
            clock_length_counters(apu)
            clock_sweeps(apu)
            
            IF NOT fc.irq_inhibit THEN
                fc.interrupt_flag = true
            END
    END
    
    fc.step = (fc.step + 1) AND 3
END

FUNCTION clock_frame_5_step(apu: PTR[APU])
    VAR fc: PTR[FrameCounter] = PTR[apu.frame_counter]
    
    SWITCH fc.step
        CASE 0:
            clock_envelopes(apu)
        
        CASE 1:
            clock_envelopes(apu)
            clock_length_counters(apu)
            clock_sweeps(apu)
        
        CASE 2:
            clock_envelopes(apu)
        
        CASE 3:
            # Nothing
        
        CASE 4:
            clock_envelopes(apu)
            clock_length_counters(apu)
            clock_sweeps(apu)
    END
    
    fc.step = fc.step + 1
    IF fc.step >= 5 THEN
        fc.step = 0
    END
END

# ============================================================================
# COMPONENT CLOCKING
# ============================================================================

FUNCTION clock_envelopes(apu: PTR[APU])
    clock_envelope(PTR[apu.pulse1.envelope])
    clock_envelope(PTR[apu.pulse2.envelope])
    clock_envelope(PTR[apu.noise.envelope])
    clock_linear_counter(PTR[apu.triangle.linear_counter])
END

FUNCTION clock_envelope(env: PTR[Envelope])
    IF env.start_flag THEN
        env.start_flag = false
        env.decay_level = 15
        env.divider_counter = env.divider_period
    ELSE
        IF env.divider_counter == 0 THEN
            env.divider_counter = env.divider_period
            
            IF env.decay_level > 0 THEN
                env.decay_level = env.decay_level - 1
            ELSE IF env.loop_flag THEN
                env.decay_level = 15
            END
        ELSE
            env.divider_counter = env.divider_counter - 1
        END
    END
END

FUNCTION clock_linear_counter(lc: PTR[LinearCounter])
    IF lc.reload_flag THEN
        lc.counter = lc.reload_value
    ELSE IF lc.counter > 0 THEN
        lc.counter = lc.counter - 1
    END
    
    IF NOT lc.control_flag THEN
        lc.reload_flag = false
    END
END

FUNCTION clock_length_counters(apu: PTR[APU])
    clock_length_counter(PTR[apu.pulse1.length_counter])
    clock_length_counter(PTR[apu.pulse2.length_counter])
    clock_length_counter(PTR[apu.triangle.length_counter])
    clock_length_counter(PTR[apu.noise.length_counter])
END

FUNCTION clock_length_counter(lc: PTR[LengthCounter])
    IF lc.value > 0 AND NOT lc.halt THEN
        lc.value = lc.value - 1
    END
END

FUNCTION clock_sweeps(apu: PTR[APU])
    clock_sweep(PTR[apu.pulse1.sweep], PTR[apu.pulse1.timer], 0)
    clock_sweep(PTR[apu.pulse2.sweep], PTR[apu.pulse2.timer], 1)
END

FUNCTION clock_sweep(sweep: PTR[Sweep], timer: PTR[Timer], channel: u8)
    VAR change_amount: u16 = timer.period >> sweep.shift
    
    IF sweep.negate THEN
        IF channel == 0 THEN
            # Pulse 1 uses one's complement
            change_amount = ~change_amount
        ELSE
            # Pulse 2 uses two's complement
            change_amount = (~change_amount) + 1
        END
        sweep.target_period = timer.period + change_amount
    ELSE
        sweep.target_period = timer.period + change_amount
    END
    
    IF sweep.divider == 0 AND sweep.enabled AND sweep.shift != 0 AND timer.period >= 8 AND sweep.target_period <= 0x7FF THEN
        timer.period = sweep.target_period
    END
    
    IF sweep.divider == 0 OR sweep.reload_flag THEN
        sweep.divider = sweep.period
        sweep.reload_flag = false
    ELSE
        sweep.divider = sweep.divider - 1
    END
END

# ============================================================================
# MIXER AND OUTPUT
# ============================================================================

FUNCTION mix_audio(apu: PTR[APU]) -> f32
    # Get individual channel outputs
    VAR pulse1_out: u8 = get_pulse_output(PTR[apu.pulse1])
    VAR pulse2_out: u8 = get_pulse_output(PTR[apu.pulse2])
    VAR triangle_out: u8 = apu.triangle.output
    VAR noise_out: u8 = get_noise_output(PTR[apu.noise])
    VAR dmc_out: u8 = apu.dmc.output
    
    # Non-linear mixing as per NES hardware
    VAR pulse_out: f32
    IF pulse1_out == 0 AND pulse2_out == 0 THEN
        pulse_out = 0.0
    ELSE
        pulse_out = 95.52 / (8128.0 / (CAST(f32, pulse1_out) + CAST(f32, pulse2_out)) + 100.0)
    END
    
    VAR tnd_out: f32
    VAR tnd_sum: f32 = CAST(f32, triangle_out) / 8227.0 + CAST(f32, noise_out) / 12241.0 + CAST(f32, dmc_out) / 22638.0
    IF tnd_sum == 0.0 THEN
        tnd_out = 0.0
    ELSE
        tnd_out = 159.79 / (1.0 / tnd_sum + 100.0)
    END
    
    RETURN pulse_out + tnd_out
END

# ============================================================================
# MAIN APU STEP
# ============================================================================

FUNCTION apu_step(apu: PTR[APU], cpu_cycles: u32)
    # Clock frame counter
    clock_frame_counter(apu)
    
    # Clock timers (some run at CPU speed, others at CPU/2)
    VAR i: u32 = 0
    WHILE i < cpu_cycles DO
        # Triangle runs at CPU speed
        clock_triangle_timer(PTR[apu.triangle])
        
        # Pulse, noise, and DMC run at CPU/2
        IF (i AND 1) == 0 THEN
            clock_pulse_timer(PTR[apu.pulse1])
            clock_pulse_timer(PTR[apu.pulse2])
            clock_noise_timer(PTR[apu.noise])
            clock_dmc_timer(PTR[apu.dmc], apu.cpu_frequency)
        END
        
        i = i + 1
    END
    
    # Generate audio samples
    apu.cycle_counter = apu.cycle_counter + CAST(f32, cpu_cycles)
    
    WHILE apu.cycle_counter >= apu.cycles_per_sample DO
        apu.cycle_counter = apu.cycle_counter - apu.cycles_per_sample
        
        # Mix and output sample
        VAR sample: f32 = mix_audio(apu)
        apu.audio_buffer[apu.buffer_position] = sample
        apu.buffer_position = apu.buffer_position + 1
        
        # Flush buffer if full
        IF apu.buffer_position >= 2048 THEN
            AudioLib.queue_audio(apu.audio_device, apu.audio_buffer, 2048)
            apu.buffer_position = 0
        END
    END
END

# ============================================================================
# STATUS AND CONTROL
# ============================================================================

FUNCTION write_status(apu: PTR[APU], value: u8)
    # Enable/disable channels
    apu.dmc.enabled = (value AND DMC_ENABLE) != 0
    apu.noise.enabled = (value AND NOISE_ENABLE) != 0
    apu.triangle.enabled = (value AND TRIANGLE_ENABLE) != 0
    apu.pulse2.enabled = (value AND PULSE2_ENABLE) != 0
    apu.pulse1.enabled = (value AND PULSE1_ENABLE) != 0
    
    # Clear length counters for disabled channels
    IF NOT apu.pulse1.enabled THEN
        apu.pulse1.length_counter.value = 0
    END
    
    IF NOT apu.pulse2.enabled THEN
        apu.pulse2.length_counter.value = 0
    END
    
    IF NOT apu.triangle.enabled THEN
        apu.triangle.length_counter.value = 0
    END
    
    IF NOT apu.noise.enabled THEN
        apu.noise.length_counter.value = 0
    END
    
    # DMC special handling
    IF NOT apu.dmc.enabled THEN
        apu.dmc.bytes_remaining = 0
    ELSE IF apu.dmc.bytes_remaining == 0 THEN
        # Restart sample
        apu.dmc.current_address = apu.dmc.sample_address
        apu.dmc.bytes_remaining = apu.dmc.sample_length
    END
    
    # Clear DMC interrupt
    apu.dmc.interrupt_flag = false
END

# ============================================================================
# INTERRUPTS
# ============================================================================

FUNCTION apu_check_irq(apu: PTR[APU]) -> bool
    RETURN apu.frame_counter.interrupt_flag OR apu.dmc.interrupt_flag
END

FUNCTION apu_clear_frame_irq(apu: PTR[APU])
    apu.frame_counter.interrupt_flag = false
END

# ============================================================================
# CLEANUP
# ============================================================================

FUNCTION apu_destroy(apu: PTR[APU])
    # Flush remaining audio
    IF apu.buffer_position > 0 THEN
        AudioLib.queue_audio(apu.audio_device, apu.audio_buffer, apu.buffer_position)
    END
    
    # Close audio device
    AudioLib.close_device(apu.audio_device)
END

