# CPU.sudo - NES CPU (RP2A03/RP2A07) Emulation
# Modified 6502 with audio/DMA features and no decimal mode

IMPORT Memory
IMPORT APU

# ============================================================================
# CONSTANTS
# ============================================================================

CONST MASK_BYTE: u8 = 0xFF
CONST MASK_WORD: u16 = 0xFFFF

# Status register flags (P register)
CONST FLAG_N: u8 = 0x80   # Negative
CONST FLAG_V: u8 = 0x40   # Overflow
CONST FLAG_U: u8 = 0x20   # Unused (always 1)
CONST FLAG_B: u8 = 0x10   # Break command
CONST FLAG_D: u8 = 0x08   # Decimal mode (disabled on NES)
CONST FLAG_I: u8 = 0x04   # IRQ disable
CONST FLAG_Z: u8 = 0x02   # Zero
CONST FLAG_C: u8 = 0x01   # Carry

# Interrupt vectors
CONST VEC_NMI: u16 = 0xFFFA
CONST VEC_RESET: u16 = 0xFFFC
CONST VEC_IRQ: u16 = 0xFFFE

# Stack base address
CONST STACK_BASE: u16 = 0x0100

# DMA constants
CONST OAM_DMA_CYCLES: u16 = 513  # 512 + 1 for odd cycle alignment

# ============================================================================
# DATA STRUCTURES
# ============================================================================

STRUCT CPU
    # Registers
    A: u8          # Accumulator
    X: u8          # Index register X
    Y: u8          # Index register Y
    P: u8          # Status register
    SP: u8         # Stack pointer (0x01FF-0x0100)
    PC: u16        # Program counter
    
    # Timing
    cycles: u64    # Total cycles executed
    stall_cycles: u16  # Cycles to stall (for DMA, etc.)
    
    # Interrupt state
    nmi_pending: bool
    nmi_edge_detected: bool
    irq_pending: bool
    
    # Emulation state
    running: bool
    
    # Memory interface
    memory: PTR[Memory.MemoryBus]
    
    # Connected components
    apu: PTR[APU.APU]
END

STRUCT AddressingResult
    address: u16
    value: u8
    page_crossed: bool
    mode: string
END

# ============================================================================
# CPU INITIALIZATION
# ============================================================================

FUNCTION cpu_create(memory: PTR[Memory.MemoryBus], apu: PTR[APU.APU]) -> CPU
    VAR cpu: CPU
    
    cpu.memory = memory
    cpu.apu = apu
    cpu.running = false
    
    # Initial register state
    cpu.A = 0
    cpu.X = 0
    cpu.Y = 0
    cpu.P = FLAG_U OR FLAG_I  # Unused bit always set, interrupts disabled
    cpu.SP = 0xFD
    cpu.PC = 0
    
    cpu.cycles = 0
    cpu.stall_cycles = 0
    
    cpu.nmi_pending = false
    cpu.nmi_edge_detected = false
    cpu.irq_pending = false
    
    RETURN cpu
END

# ============================================================================
# MEMORY ACCESS
# ============================================================================

FUNCTION read_byte(cpu: PTR[CPU], address: u16) -> u8
    RETURN Memory.read_byte(cpu.memory, address)
END

FUNCTION write_byte(cpu: PTR[CPU], address: u16, value: u8)
    Memory.write_byte(cpu.memory, address, value)
    
    # Check for special addresses
    IF address == 0x4014 THEN
        # OAM DMA
        perform_oam_dma(cpu, value)
    ELSE IF address >= 0x4000 AND address <= 0x4017 THEN
        # APU registers
        APU.apu_write_register(cpu.apu, address, value)
    END
END

FUNCTION read_word(cpu: PTR[CPU], address: u16) -> u16
    VAR lo: u8 = read_byte(cpu, address)
    VAR hi: u8 = read_byte(cpu, address + 1)
    RETURN (CAST(u16, hi) << 8) OR lo
END

FUNCTION read_word_zero_page(cpu: PTR[CPU], address: u8) -> u16
    VAR lo: u8 = read_byte(cpu, address)
    VAR hi: u8 = read_byte(cpu, (address + 1) AND 0xFF)  # Wrap within zero page
    RETURN (CAST(u16, hi) << 8) OR lo
END

FUNCTION read_word_bug(cpu: PTR[CPU], address: u16) -> u16
    # 6502 JMP indirect bug: doesn't cross page boundaries correctly
    VAR lo: u8 = read_byte(cpu, address)
    VAR hi_addr: u16
    IF (address AND 0xFF) == 0xFF THEN
        hi_addr = address AND 0xFF00  # Wrap to beginning of page
    ELSE
        hi_addr = address + 1
    END
    VAR hi: u8 = read_byte(cpu, hi_addr)
    RETURN (CAST(u16, hi) << 8) OR lo
END

# ============================================================================
# STACK OPERATIONS
# ============================================================================

FUNCTION push_byte(cpu: PTR[CPU], value: u8)
    write_byte(cpu, STACK_BASE OR cpu.SP, value)
    cpu.SP = (cpu.SP - 1) AND 0xFF
END

FUNCTION pop_byte(cpu: PTR[CPU]) -> u8
    cpu.SP = (cpu.SP + 1) AND 0xFF
    RETURN read_byte(cpu, STACK_BASE OR cpu.SP)
END

FUNCTION push_word(cpu: PTR[CPU], value: u16)
    push_byte(cpu, (value >> 8) AND 0xFF)  # High byte first
    push_byte(cpu, value AND 0xFF)         # Low byte second
END

FUNCTION pop_word(cpu: PTR[CPU]) -> u16
    VAR lo: u8 = pop_byte(cpu)
    VAR hi: u8 = pop_byte(cpu)
    RETURN (CAST(u16, hi) << 8) OR lo
END

# ============================================================================
# FLAG OPERATIONS
# ============================================================================

FUNCTION set_flag(cpu: PTR[CPU], flag: u8)
    cpu.P = cpu.P OR flag
END

FUNCTION clear_flag(cpu: PTR[CPU], flag: u8)
    cpu.P = cpu.P AND (NOT flag)
END

FUNCTION get_flag(cpu: PTR[CPU], flag: u8) -> bool
    RETURN (cpu.P AND flag) != 0
END

FUNCTION set_flag_value(cpu: PTR[CPU], flag: u8, value: bool)
    IF value THEN
        set_flag(cpu, flag)
    ELSE
        clear_flag(cpu, flag)
    END
END

FUNCTION update_zero_negative(cpu: PTR[CPU], value: u8)
    set_flag_value(cpu, FLAG_Z, value == 0)
    set_flag_value(cpu, FLAG_N, (value AND 0x80) != 0)
END

# ============================================================================
# ADDRESSING MODES
# ============================================================================

FUNCTION address_immediate(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    result.address = cpu.PC
    result.value = read_byte(cpu, cpu.PC)
    result.page_crossed = false
    result.mode = "immediate"
    cpu.PC = cpu.PC + 1
    RETURN result
END

FUNCTION address_zero_page(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    result.address = read_byte(cpu, cpu.PC)
    result.value = read_byte(cpu, result.address)
    result.page_crossed = false
    result.mode = "zeropage"
    cpu.PC = cpu.PC + 1
    RETURN result
END

FUNCTION address_zero_page_x(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR base: u8 = read_byte(cpu, cpu.PC)
    result.address = (base + cpu.X) AND 0xFF
    result.value = read_byte(cpu, result.address)
    result.page_crossed = false
    result.mode = "zeropage,x"
    cpu.PC = cpu.PC + 1
    RETURN result
END

FUNCTION address_zero_page_y(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR base: u8 = read_byte(cpu, cpu.PC)
    result.address = (base + cpu.Y) AND 0xFF
    result.value = read_byte(cpu, result.address)
    result.page_crossed = false
    result.mode = "zeropage,y"
    cpu.PC = cpu.PC + 1
    RETURN result
END

FUNCTION address_absolute(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    result.address = read_word(cpu, cpu.PC)
    result.value = read_byte(cpu, result.address)
    result.page_crossed = false
    result.mode = "absolute"
    cpu.PC = cpu.PC + 2
    RETURN result
END

FUNCTION address_absolute_x(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR base: u16 = read_word(cpu, cpu.PC)
    result.address = (base + cpu.X) AND 0xFFFF
    result.value = read_byte(cpu, result.address)
    result.page_crossed = ((base AND 0xFF00) != (result.address AND 0xFF00))
    result.mode = "absolute,x"
    cpu.PC = cpu.PC + 2
    RETURN result
END

FUNCTION address_absolute_y(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR base: u16 = read_word(cpu, cpu.PC)
    result.address = (base + cpu.Y) AND 0xFFFF
    result.value = read_byte(cpu, result.address)
    result.page_crossed = ((base AND 0xFF00) != (result.address AND 0xFF00))
    result.mode = "absolute,y"
    cpu.PC = cpu.PC + 2
    RETURN result
END

FUNCTION address_indirect(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR ptr: u16 = read_word(cpu, cpu.PC)
    result.address = read_word_bug(cpu, ptr)  # JMP bug
    result.value = 0  # Not used for JMP
    result.page_crossed = false
    result.mode = "indirect"
    cpu.PC = cpu.PC + 2
    RETURN result
END

FUNCTION address_indexed_indirect(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR base: u8 = read_byte(cpu, cpu.PC)
    VAR ptr: u8 = (base + cpu.X) AND 0xFF
    result.address = read_word_zero_page(cpu, ptr)
    result.value = read_byte(cpu, result.address)
    result.page_crossed = false
    result.mode = "(indirect,x)"
    cpu.PC = cpu.PC + 1
    RETURN result
END

FUNCTION address_indirect_indexed(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR ptr: u8 = read_byte(cpu, cpu.PC)
    VAR base: u16 = read_word_zero_page(cpu, ptr)
    result.address = (base + cpu.Y) AND 0xFFFF
    result.value = read_byte(cpu, result.address)
    result.page_crossed = ((base AND 0xFF00) != (result.address AND 0xFF00))
    result.mode = "(indirect),y"
    cpu.PC = cpu.PC + 1
    RETURN result
END

FUNCTION address_relative(cpu: PTR[CPU]) -> AddressingResult
    VAR result: AddressingResult
    VAR offset: u8 = read_byte(cpu, cpu.PC)
    cpu.PC = cpu.PC + 1
    
    # Sign extend offset
    VAR signed_offset: i16
    IF (offset AND 0x80) != 0 THEN
        signed_offset = CAST(i16, offset) OR 0xFF00
    ELSE
        signed_offset = CAST(i16, offset)
    END
    
    result.address = (CAST(i16, cpu.PC) + signed_offset) AND 0xFFFF
    result.value = 0  # Not used for branches
    result.page_crossed = ((cpu.PC AND 0xFF00) != (result.address AND 0xFF00))
    result.mode = "relative"
    RETURN result
END

# ============================================================================
# ARITHMETIC OPERATIONS
# ============================================================================

FUNCTION adc(cpu: PTR[CPU], value: u8)
    VAR carry: u16 = get_flag(cpu, FLAG_C) ? 1 : 0
    VAR sum: u16 = CAST(u16, cpu.A) + CAST(u16, value) + carry
    
    # Overflow detection
    VAR overflow: bool = ((cpu.A XOR value) AND 0x80) == 0 AND 
                        ((cpu.A XOR (sum AND 0xFF)) AND 0x80) != 0
    
    cpu.A = sum AND 0xFF
    set_flag_value(cpu, FLAG_C, sum > 0xFF)
    set_flag_value(cpu, FLAG_V, overflow)
    update_zero_negative(cpu, cpu.A)
END

FUNCTION sbc(cpu: PTR[CPU], value: u8)
    # SBC is implemented as ADC with one's complement
    adc(cpu, value XOR 0xFF)
END

FUNCTION compare(cpu: PTR[CPU], reg: u8, value: u8)
    VAR result: u16 = CAST(u16, reg) - CAST(u16, value)
    set_flag_value(cpu, FLAG_C, reg >= value)
    update_zero_negative(cpu, result AND 0xFF)
END

# ============================================================================
# BITWISE OPERATIONS
# ============================================================================

FUNCTION and_op(cpu: PTR[CPU], value: u8)
    cpu.A = cpu.A AND value
    update_zero_negative(cpu, cpu.A)
END

FUNCTION ora_op(cpu: PTR[CPU], value: u8)
    cpu.A = cpu.A OR value
    update_zero_negative(cpu, cpu.A)
END

FUNCTION eor_op(cpu: PTR[CPU], value: u8)
    cpu.A = cpu.A XOR value
    update_zero_negative(cpu, cpu.A)
END

FUNCTION bit_op(cpu: PTR[CPU], value: u8)
    VAR result: u8 = cpu.A AND value
    set_flag_value(cpu, FLAG_Z, result == 0)
    set_flag_value(cpu, FLAG_V, (value AND 0x40) != 0)
    set_flag_value(cpu, FLAG_N, (value AND 0x80) != 0)
END

# ============================================================================
# SHIFT AND ROTATE OPERATIONS
# ============================================================================

FUNCTION asl_op(cpu: PTR[CPU], value: u8) -> u8
    set_flag_value(cpu, FLAG_C, (value AND 0x80) != 0)
    VAR result: u8 = (value << 1) AND 0xFF
    update_zero_negative(cpu, result)
    RETURN result
END

FUNCTION lsr_op(cpu: PTR[CPU], value: u8) -> u8
    set_flag_value(cpu, FLAG_C, (value AND 0x01) != 0)
    VAR result: u8 = value >> 1
    update_zero_negative(cpu, result)
    RETURN result
END

FUNCTION rol_op(cpu: PTR[CPU], value: u8) -> u8
    VAR carry: u8 = get_flag(cpu, FLAG_C) ? 1 : 0
    set_flag_value(cpu, FLAG_C, (value AND 0x80) != 0)
    VAR result: u8 = ((value << 1) OR carry) AND 0xFF
    update_zero_negative(cpu, result)
    RETURN result
END

FUNCTION ror_op(cpu: PTR[CPU], value: u8) -> u8
    VAR carry: u8 = get_flag(cpu, FLAG_C) ? 0x80 : 0
    set_flag_value(cpu, FLAG_C, (value AND 0x01) != 0)
    VAR result: u8 = (value >> 1) OR carry
    update_zero_negative(cpu, result)
    RETURN result
END

# ============================================================================
# INCREMENT/DECREMENT OPERATIONS
# ============================================================================

FUNCTION inc_op(cpu: PTR[CPU], value: u8) -> u8
    VAR result: u8 = (value + 1) AND 0xFF
    update_zero_negative(cpu, result)
    RETURN result
END

FUNCTION dec_op(cpu: PTR[CPU], value: u8) -> u8
    VAR result: u8 = (value - 1) AND 0xFF
    update_zero_negative(cpu, result)
    RETURN result
END

# ============================================================================
# BRANCH OPERATIONS
# ============================================================================

FUNCTION branch(cpu: PTR[CPU], condition: bool) -> u8
    VAR addr_result: AddressingResult = address_relative(cpu)
    
    IF condition THEN
        VAR cycles: u8 = 1  # Base cycle for taken branch
        
        IF addr_result.page_crossed THEN
            cycles = cycles + 1  # Page crossing penalty
        END
        
        cpu.PC = addr_result.address
        RETURN cycles
    ELSE
        RETURN 0
    END
END

# ============================================================================
# INTERRUPT HANDLING
# ============================================================================

FUNCTION trigger_nmi(cpu: PTR[CPU])
    cpu.nmi_pending = true
    cpu.nmi_edge_detected = true
END

FUNCTION trigger_irq(cpu: PTR[CPU])
    cpu.irq_pending = true
END

FUNCTION handle_interrupt(cpu: PTR[CPU], vector: u16, is_brk: bool)
    # Push PC
    push_word(cpu, cpu.PC)
    
    # Push status with B flag
    VAR status: u8 = cpu.P OR FLAG_U  # Unused flag always set
    IF is_brk THEN
        status = status OR FLAG_B
    ELSE
        status = status AND (NOT FLAG_B)
    END
    push_byte(cpu, status)
    
    # Set interrupt disable
    set_flag(cpu, FLAG_I)
    
    # Jump to vector
    cpu.PC = read_word(cpu, vector)
END

FUNCTION check_interrupts(cpu: PTR[CPU])
    # NMI has priority over IRQ
    IF cpu.nmi_pending AND cpu.nmi_edge_detected THEN
        cpu.nmi_pending = false
        cpu.nmi_edge_detected = false
        handle_interrupt(cpu, VEC_NMI, false)
        cpu.cycles = cpu.cycles + 7
    ELSE IF cpu.irq_pending AND NOT get_flag(cpu, FLAG_I) THEN
        cpu.irq_pending = false
        handle_interrupt(cpu, VEC_IRQ, false)
        cpu.cycles = cpu.cycles + 7
    END
END

# ============================================================================
# DMA OPERATIONS
# ============================================================================

FUNCTION perform_oam_dma(cpu: PTR[CPU], page: u8)
    VAR base_addr: u16 = CAST(u16, page) << 8
    VAR i: u16 = 0
    
    # DMA takes 513 or 514 cycles (513 + 1 if on odd cycle)
    cpu.stall_cycles = OAM_DMA_CYCLES
    IF (cpu.cycles AND 1) != 0 THEN
        cpu.stall_cycles = cpu.stall_cycles + 1
    END
    
    # Copy 256 bytes to OAM
    WHILE i < 256 DO
        VAR value: u8 = read_byte(cpu, base_addr + i)
        write_byte(cpu, 0x2004, value)  # OAMDATA
        i = i + 1
    END
END

# ============================================================================
# INSTRUCTION EXECUTION
# ============================================================================

FUNCTION execute_instruction(cpu: PTR[CPU]) -> u8
    VAR opcode: u8 = read_byte(cpu, cpu.PC)
    cpu.PC = cpu.PC + 1
    
    VAR base_cycles: u8 = 2  # Most instructions take at least 2 cycles
    VAR extra_cycles: u8 = 0
    
    SWITCH opcode
        # ADC - Add with Carry
        CASE 0x69:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            adc(cpu, addr.value)
            base_cycles = 2
        
        CASE 0x65:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            adc(cpu, addr.value)
            base_cycles = 3
        
        CASE 0x75:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            adc(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x6D:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            adc(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x7D:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            adc(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x79:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            adc(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x61:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            adc(cpu, addr.value)
            base_cycles = 6
        
        CASE 0x71:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            adc(cpu, addr.value)
            base_cycles = 5
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # AND - Logical AND
        CASE 0x29:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            and_op(cpu, addr.value)
            base_cycles = 2
        
        CASE 0x25:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            and_op(cpu, addr.value)
            base_cycles = 3
        
        CASE 0x35:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            and_op(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x2D:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            and_op(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x3D:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            and_op(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x39:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            and_op(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x21:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            and_op(cpu, addr.value)
            base_cycles = 6
        
        CASE 0x31:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            and_op(cpu, addr.value)
            base_cycles = 5
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # ASL - Arithmetic Shift Left
        CASE 0x0A:  # Accumulator
            cpu.A = asl_op(cpu, cpu.A)
            base_cycles = 2
        
        CASE 0x06:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            VAR result: u8 = asl_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 5
        
        CASE 0x16:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            VAR result: u8 = asl_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x0E:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            VAR result: u8 = asl_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x1E:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            VAR result: u8 = asl_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 7
        
        # BIT - Bit Test
        CASE 0x24:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            bit_op(cpu, addr.value)
            base_cycles = 3
        
        CASE 0x2C:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            bit_op(cpu, addr.value)
            base_cycles = 4
        
        # Branch Instructions
        CASE 0x10:  # BPL - Branch if Positive
            extra_cycles = branch(cpu, NOT get_flag(cpu, FLAG_N))
            base_cycles = 2
        
        CASE 0x30:  # BMI - Branch if Minus
            extra_cycles = branch(cpu, get_flag(cpu, FLAG_N))
            base_cycles = 2
        
        CASE 0x50:  # BVC - Branch if Overflow Clear
            extra_cycles = branch(cpu, NOT get_flag(cpu, FLAG_V))
            base_cycles = 2
        
        CASE 0x70:  # BVS - Branch if Overflow Set
            extra_cycles = branch(cpu, get_flag(cpu, FLAG_V))
            base_cycles = 2
        
        CASE 0x90:  # BCC - Branch if Carry Clear
            extra_cycles = branch(cpu, NOT get_flag(cpu, FLAG_C))
            base_cycles = 2
        
        CASE 0xB0:  # BCS - Branch if Carry Set
            extra_cycles = branch(cpu, get_flag(cpu, FLAG_C))
            base_cycles = 2
        
        CASE 0xD0:  # BNE - Branch if Not Equal
            extra_cycles = branch(cpu, NOT get_flag(cpu, FLAG_Z))
            base_cycles = 2
        
        CASE 0xF0:  # BEQ - Branch if Equal
            extra_cycles = branch(cpu, get_flag(cpu, FLAG_Z))
            base_cycles = 2
        
        # BRK - Break
        CASE 0x00:
            cpu.PC = cpu.PC + 1  # Skip padding byte
            handle_interrupt(cpu, VEC_IRQ, true)
            base_cycles = 7
        
        # CMP - Compare Accumulator
        CASE 0xC9:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 2
        
        CASE 0xC5:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 3
        
        CASE 0xD5:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 4
        
        CASE 0xCD:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 4
        
        CASE 0xDD:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0xD9:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0xC1:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 6
        
        CASE 0xD1:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            compare(cpu, cpu.A, addr.value)
            base_cycles = 5
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # CPX - Compare X
        CASE 0xE0:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            compare(cpu, cpu.X, addr.value)
            base_cycles = 2
        
        CASE 0xE4:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            compare(cpu, cpu.X, addr.value)
            base_cycles = 3
        
        CASE 0xEC:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            compare(cpu, cpu.X, addr.value)
            base_cycles = 4
        
        # CPY - Compare Y
        CASE 0xC0:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            compare(cpu, cpu.Y, addr.value)
            base_cycles = 2
        
        CASE 0xC4:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            compare(cpu, cpu.Y, addr.value)
            base_cycles = 3
        
        CASE 0xCC:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            compare(cpu, cpu.Y, addr.value)
            base_cycles = 4
        
        # DEC - Decrement Memory
        CASE 0xC6:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            VAR result: u8 = dec_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 5
        
        CASE 0xD6:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            VAR result: u8 = dec_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0xCE:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            VAR result: u8 = dec_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0xDE:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            VAR result: u8 = dec_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 7
        
        # EOR - Exclusive OR
        CASE 0x49:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 2
        
        CASE 0x45:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 3
        
        CASE 0x55:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x4D:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x5D:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x59:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x41:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 6
        
        CASE 0x51:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            eor_op(cpu, addr.value)
            base_cycles = 5
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # Flag Operations
        CASE 0x18:  # CLC - Clear Carry
            clear_flag(cpu, FLAG_C)
            base_cycles = 2
        
        CASE 0x38:  # SEC - Set Carry
            set_flag(cpu, FLAG_C)
            base_cycles = 2
        
        CASE 0x58:  # CLI - Clear Interrupt
            clear_flag(cpu, FLAG_I)
            base_cycles = 2
        
        CASE 0x78:  # SEI - Set Interrupt
            set_flag(cpu, FLAG_I)
            base_cycles = 2
        
        CASE 0xB8:  # CLV - Clear Overflow
            clear_flag(cpu, FLAG_V)
            base_cycles = 2
        
        CASE 0xD8:  # CLD - Clear Decimal
            clear_flag(cpu, FLAG_D)
            base_cycles = 2
        
        CASE 0xF8:  # SED - Set Decimal
            set_flag(cpu, FLAG_D)
            base_cycles = 2
        
        # INC - Increment Memory
        CASE 0xE6:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            VAR result: u8 = inc_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 5
        
        CASE 0xF6:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            VAR result: u8 = inc_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0xEE:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            VAR result: u8 = inc_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0xFE:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            VAR result: u8 = inc_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 7
        
        # JMP - Jump
        CASE 0x4C:  # Absolute
            cpu.PC = read_word(cpu, cpu.PC)
            base_cycles = 3
        
        CASE 0x6C:  # Indirect
            VAR addr: AddressingResult = address_indirect(cpu)
            cpu.PC = addr.address
            base_cycles = 5
        
        # JSR - Jump to Subroutine
        CASE 0x20:
            VAR target: u16 = read_word(cpu, cpu.PC)
            cpu.PC = cpu.PC + 1  # Point to last byte of JSR
            push_word(cpu, cpu.PC)
            cpu.PC = target
            base_cycles = 6
        
        # LDA - Load Accumulator
        CASE 0xA9:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 2
        
        CASE 0xA5:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 3
        
        CASE 0xB5:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 4
        
        CASE 0xAD:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 4
        
        CASE 0xBD:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0xB9:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0xA1:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 6
        
        CASE 0xB1:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            cpu.A = addr.value
            update_zero_negative(cpu, cpu.A)
            base_cycles = 5
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # LDX - Load X
        CASE 0xA2:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            cpu.X = addr.value
            update_zero_negative(cpu, cpu.X)
            base_cycles = 2
        
        CASE 0xA6:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            cpu.X = addr.value
            update_zero_negative(cpu, cpu.X)
            base_cycles = 3
        
        CASE 0xB6:  # Zero Page,Y
            VAR addr: AddressingResult = address_zero_page_y(cpu)
            cpu.X = addr.value
            update_zero_negative(cpu, cpu.X)
            base_cycles = 4
        
        CASE 0xAE:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            cpu.X = addr.value
            update_zero_negative(cpu, cpu.X)
            base_cycles = 4
        
        CASE 0xBE:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            cpu.X = addr.value
            update_zero_negative(cpu, cpu.X)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # LDY - Load Y
        CASE 0xA0:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            cpu.Y = addr.value
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 2
        
        CASE 0xA4:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            cpu.Y = addr.value
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 3
        
        CASE 0xB4:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            cpu.Y = addr.value
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 4
        
        CASE 0xAC:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            cpu.Y = addr.value
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 4
        
        CASE 0xBC:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            cpu.Y = addr.value
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # LSR - Logical Shift Right
        CASE 0x4A:  # Accumulator
            cpu.A = lsr_op(cpu, cpu.A)
            base_cycles = 2
        
        CASE 0x46:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            VAR result: u8 = lsr_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 5
        
        CASE 0x56:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            VAR result: u8 = lsr_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x4E:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            VAR result: u8 = lsr_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x5E:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            VAR result: u8 = lsr_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 7
        
        # NOP - No Operation
        CASE 0xEA:
            base_cycles = 2
        
        # ORA - Logical OR
        CASE 0x09:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 2
        
        CASE 0x05:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 3
        
        CASE 0x15:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x0D:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 4
        
        CASE 0x1D:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x19:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0x01:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 6
        
        CASE 0x11:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            ora_op(cpu, addr.value)
            base_cycles = 5
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # Register Transfer
        CASE 0xAA:  # TAX
            cpu.X = cpu.A
            update_zero_negative(cpu, cpu.X)
            base_cycles = 2
        
        CASE 0x8A:  # TXA
            cpu.A = cpu.X
            update_zero_negative(cpu, cpu.A)
            base_cycles = 2
        
        CASE 0xCA:  # DEX
            cpu.X = (cpu.X - 1) AND 0xFF
            update_zero_negative(cpu, cpu.X)
            base_cycles = 2
        
        CASE 0xE8:  # INX
            cpu.X = (cpu.X + 1) AND 0xFF
            update_zero_negative(cpu, cpu.X)
            base_cycles = 2
        
        CASE 0xA8:  # TAY
            cpu.Y = cpu.A
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 2
        
        CASE 0x98:  # TYA
            cpu.A = cpu.Y
            update_zero_negative(cpu, cpu.A)
            base_cycles = 2
        
        CASE 0x88:  # DEY
            cpu.Y = (cpu.Y - 1) AND 0xFF
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 2
        
        CASE 0xC8:  # INY
            cpu.Y = (cpu.Y + 1) AND 0xFF
            update_zero_negative(cpu, cpu.Y)
            base_cycles = 2
        
        # ROL - Rotate Left
        CASE 0x2A:  # Accumulator
            cpu.A = rol_op(cpu, cpu.A)
            base_cycles = 2
        
        CASE 0x26:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            VAR result: u8 = rol_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 5
        
        CASE 0x36:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            VAR result: u8 = rol_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x2E:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            VAR result: u8 = rol_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x3E:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            VAR result: u8 = rol_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 7
        
        # ROR - Rotate Right
        CASE 0x6A:  # Accumulator
            cpu.A = ror_op(cpu, cpu.A)
            base_cycles = 2
        
        CASE 0x66:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            VAR result: u8 = ror_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 5
        
        CASE 0x76:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            VAR result: u8 = ror_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x6E:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            VAR result: u8 = ror_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 6
        
        CASE 0x7E:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            VAR result: u8 = ror_op(cpu, addr.value)
            write_byte(cpu, addr.address, result)
            base_cycles = 7
        
        # RTI - Return from Interrupt
        CASE 0x40:
            cpu.P = pop_byte(cpu) OR FLAG_U  # Ensure unused bit is set
            clear_flag(cpu, FLAG_B)  # Clear B flag
            cpu.PC = pop_word(cpu)
            base_cycles = 6
        
        # RTS - Return from Subroutine
        CASE 0x60:
            cpu.PC = pop_word(cpu) + 1
            base_cycles = 6
        
        # SBC - Subtract with Carry
        CASE 0xE9:  # Immediate
            VAR addr: AddressingResult = address_immediate(cpu)
            sbc(cpu, addr.value)
            base_cycles = 2
        
        CASE 0xE5:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            sbc(cpu, addr.value)
            base_cycles = 3
        
        CASE 0xF5:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            sbc(cpu, addr.value)
            base_cycles = 4
        
        CASE 0xED:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            sbc(cpu, addr.value)
            base_cycles = 4
        
        CASE 0xFD:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            sbc(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0xF9:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            sbc(cpu, addr.value)
            base_cycles = 4
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        CASE 0xE1:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            sbc(cpu, addr.value)
            base_cycles = 6
        
        CASE 0xF1:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            sbc(cpu, addr.value)
            base_cycles = 5
            IF addr.page_crossed THEN extra_cycles = 1 END
        
        # STA - Store Accumulator
        CASE 0x85:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            write_byte(cpu, addr.address, cpu.A)
            base_cycles = 3
        
        CASE 0x95:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            write_byte(cpu, addr.address, cpu.A)
            base_cycles = 4
        
        CASE 0x8D:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            write_byte(cpu, addr.address, cpu.A)
            base_cycles = 4
        
        CASE 0x9D:  # Absolute,X
            VAR addr: AddressingResult = address_absolute_x(cpu)
            write_byte(cpu, addr.address, cpu.A)
            base_cycles = 5
        
        CASE 0x99:  # Absolute,Y
            VAR addr: AddressingResult = address_absolute_y(cpu)
            write_byte(cpu, addr.address, cpu.A)
            base_cycles = 5
        
        CASE 0x81:  # (Indirect,X)
            VAR addr: AddressingResult = address_indexed_indirect(cpu)
            write_byte(cpu, addr.address, cpu.A)
            base_cycles = 6
        
        CASE 0x91:  # (Indirect),Y
            VAR addr: AddressingResult = address_indirect_indexed(cpu)
            write_byte(cpu, addr.address, cpu.A)
            base_cycles = 6
        
        # Stack Operations
        CASE 0x9A:  # TXS
            cpu.SP = cpu.X
            base_cycles = 2
        
        CASE 0xBA:  # TSX
            cpu.X = cpu.SP
            update_zero_negative(cpu, cpu.X)
            base_cycles = 2
        
        CASE 0x48:  # PHA
            push_byte(cpu, cpu.A)
            base_cycles = 3
        
        CASE 0x68:  # PLA
            cpu.A = pop_byte(cpu)
            update_zero_negative(cpu, cpu.A)
            base_cycles = 4
        
        CASE 0x08:  # PHP
            push_byte(cpu, cpu.P OR FLAG_U OR FLAG_B)  # Set B and U flags
            base_cycles = 3
        
        CASE 0x28:  # PLP
            cpu.P = pop_byte(cpu) OR FLAG_U  # Ensure unused bit is set
            clear_flag(cpu, FLAG_B)  # Clear B flag
            base_cycles = 4
        
        # STX - Store X
        CASE 0x86:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            write_byte(cpu, addr.address, cpu.X)
            base_cycles = 3
        
        CASE 0x96:  # Zero Page,Y
            VAR addr: AddressingResult = address_zero_page_y(cpu)
            write_byte(cpu, addr.address, cpu.X)
            base_cycles = 4
        
        CASE 0x8E:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            write_byte(cpu, addr.address, cpu.X)
            base_cycles = 4
        
        # STY - Store Y
        CASE 0x84:  # Zero Page
            VAR addr: AddressingResult = address_zero_page(cpu)
            write_byte(cpu, addr.address, cpu.Y)
            base_cycles = 3
        
        CASE 0x94:  # Zero Page,X
            VAR addr: AddressingResult = address_zero_page_x(cpu)
            write_byte(cpu, addr.address, cpu.Y)
            base_cycles = 4
        
        CASE 0x8C:  # Absolute
            VAR addr: AddressingResult = address_absolute(cpu)
            write_byte(cpu, addr.address, cpu.Y)
            base_cycles = 4
        
        # Unofficial/Illegal opcodes (common ones that some games use)
        DEFAULT:
            # For now, treat as NOP
            base_cycles = 2
    END
    
    RETURN base_cycles + extra_cycles
END

# ============================================================================
# CPU CONTROL
# ============================================================================

FUNCTION cpu_reset(cpu: PTR[CPU])
    # Read reset vector
    cpu.PC = read_word(cpu, VEC_RESET)
    
    # Reset stack pointer
    cpu.SP = cpu.SP - 3  # Simulates phantom pushes
    
    # Set interrupt disable
    set_flag(cpu, FLAG_I)
    
    # Clear decimal mode (even though it's disabled)
    clear_flag(cpu, FLAG_D)
    
    # Reset takes 7 cycles
    cpu.cycles = cpu.cycles + 7
END

FUNCTION cpu_step(cpu: PTR[CPU]) -> u8
    # Handle DMA stalls
    IF cpu.stall_cycles > 0 THEN
        VAR stall: u8 = 1
        IF cpu.stall_cycles < 256 THEN
            stall = CAST(u8, cpu.stall_cycles)
        END
        cpu.stall_cycles = cpu.stall_cycles - stall
        cpu.cycles = cpu.cycles + stall
        RETURN stall
    END
    
    # Check for interrupts
    check_interrupts(cpu)
    
    # Execute instruction
    VAR cycles: u8 = execute_instruction(cpu)
    cpu.cycles = cpu.cycles + cycles
    
    RETURN cycles
END

FUNCTION cpu_run(cpu: PTR[CPU])
    cpu.running = true
    
    WHILE cpu.running DO
        cpu_step(cpu)
    END
END

FUNCTION cpu_stop(cpu: PTR[CPU])
    cpu.running = false
END

# ============================================================================
# DEBUG HELPERS
# ============================================================================

FUNCTION cpu_get_status_string(cpu: PTR[CPU]) -> string
    VAR status: string = ""
    
    IF get_flag(cpu, FLAG_N) THEN status = status + "N" ELSE status = status + "-" END
    IF get_flag(cpu, FLAG_V) THEN status = status + "V" ELSE status = status + "-" END
    status = status + "-"  # Unused bit
    IF get_flag(cpu, FLAG_B) THEN status = status + "B" ELSE status = status + "-" END
    IF get_flag(cpu, FLAG_D) THEN status = status + "D" ELSE status = status + "-" END
    IF get_flag(cpu, FLAG_I) THEN status = status + "I" ELSE status = status + "-" END
    IF get_flag(cpu, FLAG_Z) THEN status = status + "Z" ELSE status = status + "-" END
    IF get_flag(cpu, FLAG_C) THEN status = status + "C" ELSE status = status + "-" END
    
    RETURN status
END

